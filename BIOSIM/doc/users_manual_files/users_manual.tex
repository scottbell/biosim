\documentstyle{report}

\input epsf

%\nofiles

\setlength{\textheight}{9.0in}
\setlength{\textwidth}{6.5in}
\setlength{\footheight}{0.0in}
\setlength{\topmargin}{0.00in}
\setlength{\headheight}{0.0in}
\setlength{\headsep}{0.0in}
\setlength{\oddsidemargin}{-0.0in}

\makeindex

\begin{document}

\def\topfraction{1.0}        %maximum fraction of floats at the top of the page
\def\bottomfraction{1.0}     %ditto, for the bottom of the page
\def\textfraction{0}         %minimum fraction of text (--> 100% floats is okay)
\def\floatpagefraction{1.0}  % if a page is full of floats, it'd better be FULL

\newcommand{\insertfigure}[2]{\begin{center}
                             \ \epsfxsize=#2 \epsfbox{#1.ps}
                             \end{center}}

%\newcommand{\insertfigure}[2]{\vspace{#2}}

\title{BioSim: An Integrated Simulation of an Advanced Life Support System for Intelligent Control Research\\
Users Manual (draft)}

\author{Metrica Inc. and S\&K Technologies\\
NASA Johnson Space Center/ER2\\
Houston TX 77058\\
http://www.traclabs.com/biosim}


\date{\today}

\maketitle

\tableofcontents

\newpage

\listoffigures

\newpage

\chapter{Introduction}
Advanced life support systems have multiple interacting subsystems,
which makes control a particularly challenging task.  The simulation
described in this document provides a testbed for integrated control
research.  There have been other integrated life support simulations
(e.g., \cite{finn99}) and we have learned from those efforts.  This
simulation is designed exclusively for integrated controls research,
which imposes different requirements.  For example, the simulation is
accessed through sensors and actuators, just as a real system would
be.  Noise and uncertainty are built in and controllable.
Malfunctions and failures of subsystems are modeled and manifest
themselves through anomalous readings in the sensors.  Crew members
are taskable and their tasks have purpose and meaning in the
simulation.  In essence, the simulation is a replacement for the
Advanced Life Support (ALS) hardware and crew, allowing for testing of
control approaches in advance of any integrated test.  We want the
simulation to be used to develop and evaluate integrated control
techniques.  There are still many open research questions with respect
to controlling advanced life support systems.  For example is a
distributed or hierarchical approach better?  What role does machine
learning play in control?  How can symbolic, qualitative control
approaches be integrated with continuous, quantitative approaches?
How can we evaluate different control philosophies?  We hope that the
controls community can use this simulation to begin to build systems
which will provide us with answers to these kinds of questions. 

The simulation is written in Java and is accessed using the Common
Object Request Broker Architecture (CORBA)\index{CORBA}.  The distributed nature of
the simulation allows for multiple instances to be run in parallel,
making it ideal for testing advanced control concepts such as genetic
algorithms or reinforcement learning, which require multiple trials.
See \cite{kortenkamp_etal01} or \cite{schreckenghost_etal02} for a
background on advanced life support control issues and previous work.
This document begins with a brief introduction to advanced life
support systems and provides details on installing, running and
interacting with the simulation.  The simulation is available from:

\begin{verbatim}
     http://www.traclabs.com/biosim
\end{verbatim}

\chapter{Background on advanced life support}

An advanced life support system is one in which many resources are
reused or regenerated.  Such systems will be necessary for long
duration human missions, such as those to Mars, where resupply
opportunities are limited.  Typically they have thin margins for mass,
power and buffers, which requires optimization and tight control.
Also, advanced life support systems consist of many interconnected
subsystems all of which interact in both predictable and unpredictable
ways (see Figure~\ref{fig:biosim}).  Autonomous control\index{control}
of these systems is desirable. This section gives enough background so
that users of the simulation can understand the major components of an
advanced life support system.  For detailed documentation on advanced
life support systems see \cite{tri99} or go to:

\begin{verbatim}
    http://advlifesupport.jsc.nasa.gov
\end{verbatim}

\begin{figure}
\insertfigure{figure}{5.5in}
\caption{The various modules that comprise the BIOSim integrated simulation.}
\label{fig:biosim}
\end{figure}

\section{Modules}

An advanced life support system consists of many interacting
subsystems.  While each is self-contained, they rely on each other for
various resources.  The simulation is built from a set of modules that
each produce and consume different resources.

\subsection{Environment}
\label{sec:env}
An environment\index{environment} contains air that is consumed by
either people or crops.  Air\index{air} contains a mixture of gases --
in our simulation these gases are oxygen (O2), carbon dioxide (CO2),
nitrogen (N), water vapor (H20), and other gasses (trace).  The initial composition of the
gases is set by the simulation initialization file (see
Section~\ref{sec:init}).  As the simulation runs modules may consume
air from the simulation and replace it with air of a different
composition.  Thus, the composition of gases and pressure in the air change over
time and can be measured by environment sensors
(Section~\ref{sec:env_sen}).  As with all modules, there can be
multiple environments.  For example, it is common for crew members
and crops to have different air compositions and that is the default
in this simulation.   

\subsection{Crew}
\label{sec:crew}

The crew\index{crew} module is implemented using models described in
\cite{goudarzi_ting99}.  The number, gender, age and weight of the
crew are settable as input parameters -- in the default configuration
there are four crew members, two male and two female.  The crew cycles
through a set of activities (sleep, maintenance, recreation, etc.).
As they do so they consume O2, food and water and produce CO2, dirty
water and solid waste.  The amount of resources consumed and produced
varies according to crew member attributes and their activities.  The
crew's activities can be adjusted by passing a new crew schedule to
the crew module.  A default schedule can also be used.  The crew
module is connected to a crew environment that contains an atmosphere
that they breathe.  The initial size and gas composition (percentages
of O2, CO2, H2O and inert gases) are input parameters and the default
is $1.54893 x 10^6 liters$ (from \cite{tri99}) with an atmosphere
equivalent to sea level air.  As the simulation progresses the mixture
of gases in the atmosphere changes.

\subsection{Water}
\label{sec:water}
Consumes:Power, Grey Water, Dirty Water
Produces: Potable Water

The water\index{water} recovery module consumes dirty water, grey water(i.e., water that can be used for
washing but not drinking), and power and
produces potable water.  The water recovery module consists of four
subsystems that process the water.  The biological water processing
(BWP) subsystem removes organic compounds.  Then the water passes to a
reverse osmosis (RO) subsystem, which makes 85\% of the water passing
through it grey.  The 15\% of water remaining from the RO (called
brine) is passed to the air evaporation subsystem (AES), which
recovers the rest.  These two streams of grey water (from the RO and
the AES) are passed through a post-processing subsystem (PPS) to
create potable water.  An external controller can turn on or off
various subsystems.  For example, all water can pass through the AES
at a higher power cost.  We based our water recovery module on a
recently completed test at NASA Johnson Space Center
\cite{bonasso_etal03}.

\subsection{Air}
\label{sec:air}
Consumes:Power, H2, Air, CO2, Potable Water
Produces: Air (with less CO2), O2, H2, CO2, Potable Water

The air\index{air} component takes in exhalant CO2 and produces O2 as long as
there is sufficient power being provided to the system.  This
component is modeled on various Air Revitalization System (ARS) work
at NASA JSC \cite{malin_etal00}.  There are three interacting air
subsystems: the Variable Configuration Carbon Dioxide Removal (VCCR)
System in which CO2 is removed from the air stream; the Carbon Dioxide
Reduction System (CRS), which also removes CO2 from the air stream
using a different process and producing different gases than the VCCR;
and the Oxygen Generation System (OGS) in which O2 is added to the air
stream by breaking water down into hydrogen and oxygen.  It is
important to note that both the removal of CO2 and the addition of O2
are required for human survival.  It is also important to note that
the biomass component (next subsection) also removes CO2 and adds O2.

\subsection{Biomass}
\label{sec:biomass}
Consumes:Power, Potable Water, Grey Water, Air
Produces: Air (with more CO2), Biomass, Dirty Water, CO2, Potable Water

The biomass\index{biomass} component is where crops\index{crops} are
grown.  It produces both biomass, which can be turned into
food\index{food}, and O2 and consumes water, power (light) and CO2.
This component is based on models given in \cite{jones_cavazzoni00}.
The system is modeled as shelves\index{shelves} that contain plants,
lights and water.  Shelves are planted and harvested and there is
growth cycle for each shelf.  Currently, ten crops are modeled and can
be planted in any ratio.

\subsection{Food processing}
\label{sec:food}
Consumes:Power, Biomass
Produces: Food

Before biomass can be consumed by the crew it must be converted to
food\index{food}.  The food processing component takes biomass, power and crew
time and produces food and solid waste.  The crew needs to be involved
in this process as it is labor intensive.  See Section~\ref{sec:crew}
for more information on scheduling crew activities.

\subsection{Waste}
\label{sec:waste}
Consumes:Power, Dry Waste, O2
Produces: CO2

The waste\index{waste} component consumes power, O2 and solid waste
and produces CO2.  It is modeled on an incinerator used in the Phase
III test in 1997 \cite{schreckenghost_etal02}.  Incineration can be
scheduled.

\subsection{Thermal control}
\label{sec:thermal}
Consumes: ?
Produces: ?

The thermal control\index{thermal} component regulates the air temperature in the
habitat.  This component is not implemented for this simulation and it
is assumed that external controllers are maintaining chamber
temperature.

\subsection{Power}
\label{sec:power}
Consumes: 
Produces: Power

The power\index{power} component supplies power to all of the other
components that need it.  There are two choices for power in the
simulation.  The first is nuclear\index{nuclear} power, which supplies
a fixed amount throughout the lifetime of the simulation.  The second
is solar\index{solar} power, which supplies a varying amount
(day/night cycle) of power to each component.

\subsection{Accumulators}
\label{sec:accumulator}
Consumes: All
Produces: All

The accumulator\index{accumulator} component can take a resource from any
store or environment and place it into another environment or store.  It is
functionally equivalent to an injector.

\subsection{Injectors}
\label{sec:injector}
Consumes: All
Produces: All

The injector\index{injector} component can take a resource from any
store or environment and place it into another environment or store.  It is
functionally equivalent to an accumulator.

\chapter{Simulation Properties}

The simulation implements the modules outlined in the previous
section.  BioSim does {\em not} simulate at the level of valves,
pumps, switches, etc.  Instead, modules are implemented in a
producer/consumer relationship, which is described in the next
subsection.  The simulation also provides additional functionality to
help test and debug control programs.

\section{Producer/Consumer Model}

No component in BioSim directly interacts with other components.  Instead, each component
has a rigid set of resources that it consumes and produces.  The resources are taken from stores/environments
and put into stores/environments.  The resources for BioSim currently consist of
power, potable water, grey water, dirty water, air, H2, nitrogen, O2, CO2, biomass, food, and dry waste.  At each simulation tick,
each module takes resource from it's store (it's consumables), and puts resources into stores (it's products).  Stores always report
thier values (level and capacity) from the last tick and report new values after every component in the simulation has been ticked.  
Resource conflicts can occur when two components ask for a limited resource, i.e. two WaterRS's both need 20 liters of dirty water and there
is only 20 liters in the dirty water tank.  This is currently resolved on a winner-take-all basis that is for all practical purposes
randomized.

\section{Success criteria}

In order to compare different control approaches there should be
objective criteria for a successful advanced life support system
mission.  Several possibilities exist already in the simulation.  For
example, the length of the mission before consumables are gone is a
success criterion.  As is minimizing the starting levels of stores or
minimizing the sizes of intermediary buffers.  However, many of these
fail to get at the true success of a mission, the productivity of the
crew in performing their science objectives.  Thus, the simulation
includes an artificial productivity\index{productivity} measure.  As
the crew cycles through their activities (see Section~\ref{sec:activities})
the amount of time they spend doing "mission" tasks is accumulated. This
number is also multiplied by a factor that takes into account the
amount of sleep, exercise, water, food and oxygen they are getting to approximate 
crew effectivness at performing the task (a happy crew is a productive crew!).
So each tick, for each crew member the productivity is given by the
following equation:

        [need to put the equation here]
	[some relevant code, derive equation later]
	\begin{verbatim}
	private static final float WATER_TILL_DEAD = 8.1f;
	private static final float WATER_RECOVERY_RATE=0.01f;
	private static final float OXYGEN_TILL_DEAD = 3f;
	private static final float OXYGEN_RECOVERY_RATE=0.01f;
	private static final float CALORIE_TILL_DEAD = 180000f;
	private static final float CALORIE_RECOVERY_RATE=0.0001f;
	private static final float DANGEROUS_CO2_RATION = 0.06f;
	private static final float CO2_TILL_DEAD = 10f;
	private static final float CO2_RECOVERY_RATE=0.001f;
	private static final float LEISURE_TILL_BURNOUT = 168f;
	private static final float LEISURE_RECOVERY_RATE=90f;
	private static final float AWAKE_TILL_EXHAUSTION = 120f;
	private static final float SLEEP_RECOVERY_RATE=12f;
	consumedWaterBuffer = new SimpleBuffer(WATER_TILL_DEAD, WATER_TILL_DEAD);
	consumedOxygenBuffer = new SimpleBuffer(OXYGEN_TILL_DEAD, OXYGEN_TILL_DEAD);
	consumedCaloriesBuffer = new SimpleBuffer(CALORIE_TILL_DEAD, CALORIE_TILL_DEAD);
	consumedCO2Buffer = new SimpleBuffer(CO2_TILL_DEAD, CO2_TILL_DEAD);
	sleepBuffer = new SimpleBuffer(AWAKE_TILL_EXHAUSTION, AWAKE_TILL_EXHAUSTION);
	leisureBuffer = new SimpleBuffer(LEISURE_TILL_BURNOUT, LEISURE_TILL_BURNOUT);
	float caloriePercentFull = sigmoidLikeProbability(consumedCaloriesBuffer.getLevel() / consumedCaloriesBuffer.getCapacity());
	float waterPercentFull = sigmoidLikeProbability(consumedWaterBuffer.getLevel() / consumedWaterBuffer.getCapacity());
	float oxygenPercentFull = sigmoidLikeProbability(consumedOxygenBuffer.getLevel() / consumedOxygenBuffer.getCapacity());
	float CO2PercentFull = sigmoidLikeProbability(consumedCO2Buffer.getLevel() / consumedCO2Buffer.getCapacity());
	float sleepPercentFull = sleepBuffer.getLevel() / sleepBuffer.getCapacity();
	float leisurePercentFull = leisureBuffer.getLevel() / leisureBuffer.getCapacity();
	float averagePercentFull = (caloriePercentFull + waterPercentFull + oxygenPercentFull + CO2PercentFull + sleepPercentFull + leisurePercentFull) / 6f;
	myMissionProductivity += myCrewGroup.randomFilter(averagePercentFull);
	\end{verbatim}
\section{Stochastic processes}

Any sufficiently complex process, especially one with biological
components, will not be deterministic\index{deterministic}.  That is,
given the same starting conditions and inputs it will not produce the
exact same outputs each time it is run.  A
stochastic\index{stochastic} process is one in which chance or
probability affect the outcome.  This simulation offers both
deterministic and stochastic operations.  In the former case, running
the simulation twice with the same inputs and initial conditions will
produce the same results.  This may be useful for quantitatively
comparing different control approaches against each other.  In the
latter case, the user can control the amount of variability in the
simulation (see Section 7.4).  This is modeled using a Gaussian\index{Gaussian}
distribution [[Scott fill this in more]].  This can be used to test a
control system’s ability to deal with stochastic processes.

\section{Malfunctions}

The simulation also has the ability to accept
malfunction\index{malfunctions} requests (see Section 7.5).  These
requests will change the operating regime of the simulation.  For
example, by causing a crew member to be sick, power supplies to drop,
water to leak, plants to die, etc.  Different modules will have
different sensitivities, for example once plants die they cannot
recover, but if the water module is damaged and then repaired it will
operate normally.  Of course, if levels of CO2, water or food reach
hard-coded critical levels the crew will abandon the mission and return
home.

\section{Crew activity scheduling}
\label{sec:activities}
Crew members in an advanced life support system do not just consume
and produce -- they do activities.  These may be science, maintenance,
exercise, sleep, etc.  The different activities go for a specified length
and for a specified intensity.  The intensity is tied to how many resources the crew
member will consume performing the activity (e.g., sleep takes less 02 to perform than exercise).  
The following diagram shows the nominal daily routine for a crew member:

Schedule loop:
	Sleep for 8 hours
	Hygiene for 1 hour
	Exercise for 1 hour
	Eating for 1 hour
	Mission tasks for 8 hours
	Health for 1 hour
	Maintenance for 1 hour
	Leisure for 2 hours

This schedule can be interrupted by malfunctions (a crew member's activity changed to repair),
sickness, or even mission end (if the crew member hasn't recieved proper resources).

\section{Mass balance}
Mass balanced means resources consumed by components are returned in totality (but usually in a different form) to stores, no mass is lost.
This is important for closed loop simulations as it verfies the models (under perfect conditions) are keeping with the conversation of energy and mass.
Our simulation has been mass balanced to a reasonable degree.  There is a slight loss in mass from the crew (they don't gain weight from eating or produce heat)
and from the plants (who don't produce heat).  We plan to address these issues in the future, but the simulation is currently mass balanced
enough to provide a very decent closed loop simulation.


\chapter{Simulation implementation}

All of the simulation components are written in Java\index{Java} to
make the simulation portable.  Each component can be run as it's own
CORBA\index{CORBA} server so that they can be distributed across
computers for increased performance, or the entire simulation can be run on one server.  We have tested the simulation on
Windows\index{Windows}, Unix\index{Unix} and
Macintosh\index{Macintosh} computers.  A user interface allows for
insight into the simulation which provides real time graphing and more.  There is also a logging\index{logging}
facility that will automatically save all simulation values to a file (xml)
or a database (in development).  We have written Java and C++\index{C++} interfaces to the simulation, though any
language that supports CORBA should be able to access the simulation.

(BioSim) <-> Server ORB <-> Client ORB <-> (Client)

I think we should provide a link to a CORBA tutorial, but assume knowledge of basics of CORBA.
Explain object oriented methodology and how it relates to BioSim.
Would a figure be good here showing the relationship between servers,
clients, CORBA, etc.?

\chapter{Installing the simulation}
The simulation is written in Java and can run on most popular
operating systems.  We provide both an executable for Windows and
source code for any operating system.  This chapter deals with
installing the code onto your computer. 

\section{Installing an executable}

An executable that will run under most Windows operating systems is
available.  You can download the Windows executable from: {\tt
  www.traclabs.com/biosim}.

At that site, go to Download and then download the Windows
installer\index{installation}.  Remember where you put it.
Double-click on the Setup.exe icon, accept the agreement, choose the
default installation, install it where you desire and then click
``Finish''.  BIOSim will start automatically.  NOTE: If you do not
have Java\index{Java} installed on your PC then the installer will
direct you to the WWW page to download it (free).  Please e-mail Scott
Bell (scott@traclabs.com) if you have trouble with installing the
simulation.

\begin{figure}
\insertfigure{labelled_interface}{5.5in}
\caption{BioSim’s graphical user interface.}
\label{fig:empty_interface}
\end{figure}

\section{Installing source code}

Please read the README.txt file in the doc directory of your BIOSIM distribution.

\chapter{Running the simulation}
\label{sec:running}

Doubleclicking on the ``BioSim'' icon in Windows will start the
simulation.  In Linux, run the {\tt run-biosim.sh} shell script in the
{\tt /bin} directory.  When BioSim starts you'll see a blank
interface\index{interface} as shown in
Figure~\ref{fig:empty_interface}.  Holding your mouse over the buttons
on the top reveals what they do.  As noted in the figure, the first
three buttons control the simulation.  The next series of buttons will
display various subsystem views. Some of the views, like the crew, do
not contain anything until the simulation is started.  I like to open
up the main subsystem views before starting the simulation.

The open interface is shown in Figure~\ref{fig:full_interface}.  The
view can be changed between text, chart and schematic by clicking on
the tabs.  The simulation will run until resources (air, water, food,
etc.) drop below critical levels.  Then the simulation will stop.
Pressing the start button will restart the simulation from the
beginning.  If you want to examine the interfaces closely press the
``Pause'' button or go through the simulation one step at a time.

\begin{figure}
\insertfigure{open_interface}{5.5in}
\caption{A full view of BioSim’s graphical user interface}
\label{fig:full_interface}
\end{figure}

\chapter{Configuring the simulation}
The previous chapter discussed installing and running the default
BioSim.  This section will discuss configuring BioSim to address
specific user interests.  This includes changing the underlying
producer/consumer relationship, changing the stochastic nature of
BioSim and changing the logging of data.  We start with some basic
CORBA infrastructure requirements.     

\section{CORBA, Orbs and namesevers}

BioSim is a server.  Client programs connect to BioSim via
CORBA\index{CORBA} -- the Common Object Request Broker Architecture.
In order to connect to the BioSim server will you will need to install
an Object Request Broker (ORB)\index{ORB} on your machine.  We
recommend the JacORB for Java (http://www.jacorb.org) and the ACEOrb for C++ (http://www.cs.wustl.edu/~schmidt/TAO.html), 
although any CORBA-compliant ORB will work.  When the BioSim
server is started it registers with a nameserver\index{nameserver},
which tells client programs where to find it.  The ORBs we recommend
include a name server.  This manual will not cover the details of
CORBA, we refer you to any book on CORBA for your language or look at
the sample programs in Appendix A and B.  We also assume that you have
already installed one of the ORBs.
   
\section{Initial conditions}
\label{sec:init}
BioSim is almost infinitely reconfigurable\index{recongifuration} --
from the number of crew members to the size and number of the
different modules and should be able to provide scenarios ranging from quick shuttle launces to Mars colonies.  
The start-up configuration of BioSim is controlled
by an eXtensible Markup Language (XML)\index{XML} file that is read in
during BioSim initialization.  If you want to change BioSim's
configuration you need to change the XML file.  The default XML file
is located in:

\begin{verbatim}
   BIOSIM/resources/biosim/server/framework/DefaultInitialization.xml
\end{verbatim}

\noindent where {\tt BIOSIM} is the directory where you installed
BioSim.

You can copy this file, change it's name, modify it and then give its
full path name as a parameter to BioSim on startup.  The flag when you
start BioSim is {\tt -xml} followed by the full path name of the XML
file.  If you do not wish to change the initial configuration of
BioSim you can skip the rest of this section. 

\subsection{XML file format}
A snippet from the default initialization XML file is shown below:

\begin{verbatim}
  <SimBioModules>
    <crew>
      <CrewGroup name="CrewGroup">
        <potableWaterConsumer maxFlowRates="100" desiredFlowRates="100" inputs="PotableWaterStore"/>
        <airConsumer maxFlowRates="0" desiredFlowRates="0" inputs="CrewEnvironment"/>
        <foodConsumer maxFlowRates="100'' desiredFlowRates="100" inputs="FoodStore"/>
        <dirtyWaterProducer maxFlowRates="100" desiredFlowRates="100" outputs="DirtyWaterStore"/>
        <greyWaterProducer maxFlowRates="100" desiredFlowRates="100" outputs="GreyWaterStore"/>
        <airProducer maxFlowRates="0" desiredFlowRates="0" outputs="CrewEnvironment"/>
         .
         .
         .
        <crewPerson name="Bob Roberts" age="43" weight="77" sex="MALE">
          <schedule>
            <activity name="sleep" length="8" intensity="1"/>
            <activity name="hygiene" length="1" intensity="2"/>
            <activity name="exercise" length="1" intensity="5"/>
            <activity name="eating" length="1" intensity="2"/>
            <activity name="mission" length="9" intensity="3"/>
            <activity name="health" length="1" intensity="2"/>
            <activity name="maintenance" length="1" intensity="2"/>
            <activity name="leisure" length="2" intensity="2"/>
          </schedule>
        </crewPerson>                               
         .
         .
         .
      </crew>
\end{verbatim}

This file implements the producer/consumer relationship at the heart
of the simulation.  Each module (only the crew module is shown above)
has a name and a list of resources that it consumes and produces along with max
and desired flow rates and what source(s) produce(s) that resource
(the {\tt inputs}) or from where the resource is drawn ({\tt outputs})
More than one source or sink is allowed, but the module tries to draw as much as it can from the first.
In the above snippet some flow rates are 0 because the user has no control over
them (e.g., crew air consumption is based on crew physiology and can't
be directly controlled).  As shown above, you can have as many (or as
few) crew members as you want of various ages, weights and sexes.  You
can give a default schedule for their day (which can be changed via a
CORBA API call during simulation runs). 

The rest of the XML file specification proceeds in a similar way.  The
best way to change the configuration is to start with the default file
and edit it to reflect your requirements.  The default configuration
is based on BIO-Plex\index{BIO-Plex} \cite{tri99}, a NASA JSC ground
testbed for advanced life support.  As such, if all you want is a
``typical'' advanced life support configuration, then just use the
default XML file.

\subsection{Initializing BioSim}

Talk about alternative initialization\index{initialization} via an
API.  Again, capacities, levels, logging, etc. can be set from here.

\section{Enabling stochastic processes}
\index{stochastic}
BioSim provides the ability to change the stochastic nature of the
underlying modules via API calls or the XML initialization file.  If you want a purely deterministic
simulation you can do that.  If you want a very unpredictable
simulation you can do that as well.  This section provides an overview
of the stochastic controls available in BioSim.
The type {\tt StochasticIntensity} includes the following values:

\begin{itemize}
\item {\tt HIGH\_STOCH}
\item {\tt MEDIUM\_STOCH}
\item {\tt LOW\_STOCH}
\item {\tt NONE\_STOCH}
\end{itemize}

Each of these controls the width of the Gaussian\index{Gaussian}
function that provides the variations in output.  Setting the
stochastic intensity to NONE\_STOCH means that the simulation is
deterministic.  All noise is Gaussian.  The outputs of a module as
determined by the module's underlying equations are run through a
Gaussian filter before being output by the simulation.  The Gaussian
filter's parameters are controlled by the stochastic intensity, namely 
the higher the stochastic intensity, the higher the deviation.  

\subsection{Setting logging via the XML configuration file}
To change the stochastic intensity of a module in XML, simply add
setStochasticIntensity as an attribute to the module (if one isn't listed, it defaults to NONE\_STOCH).
example: <AirRS name="AirRS" setStochasticIntensity="HIGH\_STOCH">

The stochastic level for the entire simulation (which is equivalent to
setting each module's stochastic intensity) can by adding setStochasticIntensity to the Globals section at the head
of the XML document.
example:
<Globals crewsToWatch="CrewGroup" setStochasticIntensity="LOW\_STOCH">

\subsection{Setting logging via the API}
Each module of BioSim (i.e., the {\tt SimBioModule} class) has the
following methods:

\begin{itemize}
\item {\tt getStochasticIntensity()}: returns type {\tt
    StochasticIntensity}, which is the current stochastic level of the module.
\item {\tt setStochasticIntensity(StochasticIntensity pIntensity)}:
  Sets the current stochastic intensity of the module to {\tt
  pIntensity}.
\end{itemize}
The stochastic level for the entire simulation (which is equivalent to
setting each module's stochastic intensity) can be set via the {\tt
BioDriver} class using the {\tt setStochasticIntensity} method with
the same parameter ({\tt (StochasticIntensity})

\section{Logging}
\index{logging}

\subsection{Setting logging via the XML configuration file}

To change the logging of a module in XML, add
isLoggingEnabled as an attribute to the module (if one isn't listed, it defaults to false).
example: <AirRS name="AirRS" isLoggingEnabled="true">
You can also globally enable logging for the senors, actuators, or everything by adding
isFullLoggingEnabled, isSensorLoggingEnabled or isActuatorLoggingEnabled to the Globals section at the head
of the XML document.
example:
<Globals crewsToWatch="CrewGroup" isFullLoggingEnabled="true">

\subsection{Setting logging via the API}

Each module of BioSim (i.e., the {\tt SimBioModule} class) has the
following methods:

\begin{itemize}
\item {\tt isLogging()}: returns type {\tt
    boolean}, whether the module is logging.
\item {\tt setLogging(boolean pLogging)}:
  Sets whether the module should log.
\end{itemize}

\begin{figure}
\insertfigure{controller}{4.0in}
\caption{Interaction with the simulation.}
\label{fig:controller}
\end{figure}

\chapter{Controlling the simulation}
The previous two chapters showed you how to run BioSim, monitor its
internal state via a graphical user interface and configure it to your
specifications.  While interesting, this is not useful for control
system research.  This chapter will show you how to connect an
external control program to BioSim and change its underlying
operation.  Note that this chapter will not present an exhaustive list
of all of the objects and methods in BioSim, but only the most
important for new users.  Complete documentation of all objects and
method calls is available at:
http://www.traclabs.com/biosim/doc/api/index.html

Figure~\ref{fig:controller} shows the basic control strategy for the
simulation.  The simulation models represent the underlying equations
that govern the producer/consumer relationships (see
Section~\ref{sec:pc}).  Sensors and actuators are provided to access
the underlying simulations.  The user is responsible for writing the
controller, which uses the sensors and actuators to control the
simulation.  The user can also inject malfunctions into the underlying
simulation models and resupply consumables.   

\section{Controlling simulation runs}
The root class of the simulation is the {\tt BioDriver} class, which
contains the methods used to control the simulation.  The basic
control unit is a {\bf tick}\index{tick}, which advances the
simulation exactly one hour.  After creating your own BioDriver the
following methods are available:

\begin{enumerate}
\item  {\tt void advanceOneTick()}: Moves all modules of the
  simulation ahead exactly one hour.
\item {\tt void endSimulation()}: Ends\index{end} the simulation entirely.
\item {\tt boolean isDone()}: \index{isDone} Returns true if the simulation has met
  an end condition and has stopped.
\item {\tt void reset() }:\index{reset} Returns the simulation to its initial
  state.
\end{enumerate}

Here's an example of using one of these methods after a BioDriver
class has been created (called {\tt myBioDriver}) in a Java program:

\begin{verbatim}

    myBioDriver.advanceOneTick();

\end{verbatim}

There are a number of other methods available in the BioDriver class
that are less commonly used than those listed above.  These are
available via the JavaDoc\index{JavaDoc} facility.  After you have
installed your source code you can make documentation via the {\tt
  make-docs.sh} (for Linux) or {\tt make-docs} (for Windows)
executables in the {\tt bin} directory.  The BioDriverImpl class is
under the biosim.server.framework package.

\section{Accessing sensors and actuators}

\subsection{Generic sensors}

Sensors\index{sensors} are objects that connect to the underlying
simulation.  Each module has its own set of sensor objects, but they
all inherit the same method calls.  These method calls are:

\begin{itemize}

        \item {\tt getMax:} Returns the maximum allowed value of the sensor
        \item {\tt getMin:} Returns the minimum allowed value of the sensor
        \item {\tt getValue}: Returns the current setting of the sensor
\end{itemize}


\subsubsection{Additional sensor methods}

Several other generic methods related to sensor noise, malfunctions
and logging are available:

In addition, there will be some sensor-specific methods, which we will discuss with the appropriate sensor.

\subsection{Generic actuators}

Actuators\index{actuators} are objects that connect to the underlying simulation.  Each
module has its own set of actuator objects, but they all inherit the
same method calls.  These method calls are:

\begin{itemize}

        \item {\tt getMax}: Returns the maximum allowed value of the actuator
        \item {\tt getMin}: Returns the minimum allowed value of the actuator
        \item {\tt getValue}: Returns the current value of the actuator       
        \item {\tt setValue}: Sets the actuator

\end{itemize}

\subsubsection{Additional actuator methods}

Several other generic methods related to actuator noise, malfunctions
and logging are available:

In addition, there will be some actuator-specific methods, which we
will discuss with the appropriate actuator.


\subsection{Environments}

Environments\index{environment} contain the air\index{air} that crew
and crops use.  As there can be multiple environments in the simulation,
there can be multiple sensors tied to each environment.

\subsubsection{Sensors}
\label{sec:env_sen}
The following sensors are available in the environment:

\begin{enumerate}

\item {\tt AirInFlowRateSensor}: Flow rate in moles/tick of air into the environment
\item {\tt AirOutFlowRateSensor}: Flow rate in moles/tick of air out of the environment
\item {\tt CO2AirConcentrationSensor}: Percentage of CO2 in the environment.
\item {\tt CO2AirEnvironmentInFlowRateSensor}: Flow rate in liters/tick of CO2 into the environment
\item {\tt CO2AirEnvironmentOutFlowRateSensor}: Flow rate in liters/tick of CO2 out of the environment
\item {\tt CO2AirPressureSensor}: Pressure in kPA of CO2 in the environment
\item {\tt CO2AirStoreInFlowRateSensor}: Flow rate in liters/tick of CO2 from a store (and 
\item {\tt CO2AirStoreOutFlowRateSensor}: 
\item {\tt NitrogenAirConcentrationSensor}: Percentage of Nitrogen in the environment
\item {\tt NitrogenAirEnvironmentInFlowRateSensor}:
\item {\tt NitrogenAirEnvironmentOutFlowRateSensor}:
\item {\tt NitrogenAirPressureSensor}:
\item {\tt NitrogenAirStoreInFlowRateSensor}:
\item {\tt NitrogenAirStoreOutFlowRateSensor}:
\item {\tt O2AirConcentrationSensor}: Percentage of O2 in the environment.
\item {\tt O2AirEnvironmentInFlowRateSensor}: Flow rate in liters/tick of O2 into the environment
\item {\tt O2AirEnvironmentOutFlowRateSensor}: Flow rate in liters/tick of O2 out of the environment
\item {\tt O2AirPressureSensor}: Pressure in kPA of O2 in the environment
\item {\tt O2AirStoreInFlowRateSensor}: 
\item {\tt O2AirStoreOutFlowRateSensor}: 
\item {\tt OtherAirConcentrationSensor}:
\item {\tt OtherAirPressureSensor}:
\item {\tt WaterAirConcentrationSensor}: Percentage of water (humidity) in the environment
\item {\tt WaterAirEnvironmentInFlowRateSensor}:
\item {\tt WaterAirEnvironmentOutFlowRateSensor}:
\item {\tt WaterAirPressureSensor}:
\item {\tt WaterAirStoreInFlowRateSensor}:
\item {\tt WaterAirStoreOutFlowRateSensor}: 
\end{enumerate}

\subsubsection{Actuators}

\begin{enumerate}

\item {\tt AirInFlowRateActuator}: Flow rate in moles/tick of air into the environment
\item {\tt AirOutFlowRateActuator}: Flow rate in moles/tick of air out of the environment
\item {\tt CO2AirEnvironmentInFlowRateActuator}: Flow rate in liters/tick of CO2 into the environment
\item {\tt CO2AirEnvironmentOutFlowRateActuator}: Flow rate in liters/tick of CO2 out of the environment
\item {\tt CO2AirStoreInFlowRateActuator}: 
\item {\tt CO2AirStoreOutFlowRateActuator}: 
\item {\tt NitrogenAirEnvironmentInFlowRateActuator}:
\item {\tt NitrogenAirEnvironmentOutFlowRateActuator}:
\item {\tt NitrogenAirStoreInFlowRateActuator}:
\item {\tt NitrogenAirStoreOutFlowRateActuator}:
\item {\tt O2AirEnvironmentInFlowRateActuator}: Flow rate in liters/tick of O2 into the environment
\item {\tt O2AirEnvironmentOutFlowRateActuator}: Flow rate in liters/tick of O2 out of the environment
\item {\tt O2AirStoreInFlowRateActuator}: 
\item {\tt O2AirStoreOutFlowRateActuator}: 
\item {\tt WaterAirEnvironmentInFlowRateActuator}:
\item {\tt WaterAirEnvironmentOutFlowRateActuator}:
\item {\tt WaterAirStoreInFlowRateActuator}:
\item {\tt WaterAirStoreOutFlowRateActuator}: 

\end{enumerate}

\subsubsection{Malfunctions}

State exactly what the malfunctions do.  How do the method calls work.
What is the malfunction. What is the leak rate, etc. for each of the
different malfunction classes.  Since method calls are probably
identical may want to move this up to top and then use this section
only for module-specific malfunction information.

\subsection{Crew}
\index{crew}
\subsubsection{Sensors}

\begin{enumerate}

\item {\tt CrewGroupActivitySensor}:  Returns average activity level of crew
\item {\tt CrewGroupAnyDeadSensor}: Returns whether any crew member has died
\item {\tt CrewGroupDeathSensor}: Return whether the entire crew has died
\item {\tt CrewGroupProductivitySensor}: Total productivity of the crew

\end{enumerate}

\subsubsection{Actuators}

\begin{enumerate}

\item {\tt CrewGroupActivityActuator}:

\end{enumerate}

\subsubsection{Malfunctions}




\subsection{Air}
\index{air}
\subsubsection{Sensors}

\begin{enumerate}

\item {\tt CO2InFlowRateSensor}:
\item {\tt CO2OutFlowRateSensor}:
\item {\tt CO2StoreLevelSensor}:
\item {\tt H2InFlowRateSensor}:
\item {\tt H2OutFlowRateSensor}:
\item {\tt H2StoreLevelSensor}:
\item {\tt NitrogenInFlowRateSensor}:
\item {\tt NitrogenOutFlowRateSensor}:
\item {\tt NitrogenStoreLevelSensor}:
\item {\tt O2InFlowRateSensor}:
\item {\tt O2OutFlowRateSensor}:
\item {\tt O2StoreLevelSensor}:

\end{enumerate}

\subsubsection{Actuators}

\begin{enumerate}

\item {\tt CO2InFlowRateSensor}:
\item {\tt CO2OutFlowRateSensor}:
\item {\tt H2InFlowRateSensor}:
\item {\tt H2OutFlowRateSensor}:
\item {\tt NitrogenInFlowRateSensor}:
\item {\tt NitrogenOutFlowRateSensor}:
\item {\tt O2InFlowRateSensor}:
\item {\tt O2OutFlowRateSensor}:

\end{enumerate}

\subsubsection{Malfunctions}

Same as others


\subsection{Water}
\index{water}

\subsubsection{Sensors}
\begin{enumerate}

\item {\tt DirtyWaterInFlowRateSensor}:
\item {\tt DirtyWaterOutFlowRateSensor}:
\item {\tt DirtyWaterStoreLevelSensor}:
\item {\tt GreyWaterInFlowRateSensor}:
\item {\tt GreyWaterOutFlowRateSensor}:
\item {\tt GreyWaterStoreLevelSensor}:
\item {\tt PotableWaterInFlowRateSensor}:
\item {\tt PotableWaterOutFlowRateSensor}:
\item {\tt PotableWaterStoreLevelSensor}:
\end{enumerate}

\subsubsection{Actuators}

\begin{enumerate}

\item {\tt DirtyWaterInFlowRateActuator}:
\item {\tt DirtyWaterOutFlowRateActuator}:
\item {\tt GreyWaterInFlowRateActuator}:
\item {\tt GreyWaterOutFlowRateActuator}:
\item {\tt PotableWaterInFlowRateActuator}:
\item {\tt PotableWaterOutFlowRateActuator}:
\end{enumerate}

\subsubsection{Malfunctions}

\subsection{Biomass}
\index{biomass}

\subsubsection{Sensors}

\subsubsection{Actuators}

\subsubsection{Malfunctions}

\subsection{Solid Waste}
\index{waste}

\subsubsection{Sensors}

\subsubsection{Actuators}

\subsubsection{Malfunctions}

\subsection{Power}
\index{power}

\subsubsection{Sensors}

\begin{enumerate}
\item {\tt PowerInFlowRateSensor}:
\item {\tt PowerOutFlowRateSensor}:
\item {\tt PowerStoreLevelSensor}:
\end{enumerate}

\subsubsection{Actuators}

\begin{enumerate}
\item {\tt PowerInFlowRateActuator}:
\item {\tt PowerOutFlowRateActuator}:
\end{enumerate}

\subsubsection{Malfunctions}



\chapter{Writing a simple Java controller}

A short tutorial on creating a BioSim, initializing it and then
calling some sensors, actuators and ticks.  Assume JacOrb. 

\chapter{Writing a simple C++ controller}



Same as above in C++.  Assume ACEOrb.  Assume Linux (?).

\chapter{Control Examples}

Include GA, Rice learners, Texas Tech learner.

\chapter{Conclusions}

\appendix 
\chapter{Java Example}

\begin{verbatim}

Put parts of Rice handcontroller here

\end{verbatim}

\chapter{C++ Example}

\begin{verbatim}

#include "biosimC.h"
#include <CosNamingC.h>

static const char* CorbaServerName = "BioDriver0";
int
main(int argc,char *argv[])
{
  try {
    // Initialize orb
    CORBA::ORB_var orb = CORBA::ORB_init(argc,argv,"TestClient");

    cerr << "initialized orb" << endl;

    if (argc < 2) {
      cerr << "Usage: " << argv[0]
           << " IOR_string" << endl;
      return 1;
    }

// Use the first argument to create the object reference,
    // in real applications we use the naming service, but let's do
    // the easy part first!

    CORBA::Object_var obj =
      orb->string_to_object (argv[1]); 

    cout << "After resolve_initial_references" << endl;


    /*   CORBA::Object_var obj =
         orb->string_to_object (argv[1]); */
 
    CosNaming::NamingContext_var inc = CosNaming::NamingContext::_narrow(obj);

    cout << "After NameService narrow" << endl;

    if(CORBA::is_nil(inc)) {
      cerr << "Unable to narrow NameService." << endl;
      throw 0;
    }  // end if couldn't get root naming context
    
    CosNaming::Name name;
    name.length(1);
    name[0].id = CORBA::string_dup(CorbaServerName);
    name[0].kind = CORBA::string_dup("");

    CORBA::Object_var tmp = inc->resolve(name);

    cout << "After resolve name" << endl;

    if(CORBA::is_nil(tmp)) {
      cerr << "Unable to resolve " << CorbaServerName << " from NameService" << endl;
      throw 0;
    }  // end if couldn't find object

    cerr << "got object" << endl;

    // Now downcast the object reference to the appropriate type

    biosim::idl::framework::BioDriver_var biodriver = biosim::idl::framework::BioDriver::_narrow(tmp);


    cerr << "narrowed" << endl;

    // code here

    biodriver->spawnSimulationTillDead();

    cerr << "spawned" << endl;

    orb->destroy ();
  }
  catch (CORBA::Exception &ex) {
    std::cerr << "CORBA exception raised! " << std::endl;
  }
  return 0;
}

\end{verbatim}

\bibliography{biosim}
\bibliographystyle{plain}

\begin{theindex}

\input{users_manual.ind}

\end{theindex}


\end{document}

