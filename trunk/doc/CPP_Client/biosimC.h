// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_BIOSIMC_H_
#define _TAO_IDL_BIOSIMC_H_

#include "tao/corba.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO 

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO 
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option push -w-rvl -w-rch -w-ccc -w-inl
#endif /* __BORLANDC__ */

TAO_NAMESPACE  biosim
{
    TAO_NAMESPACE  idl
  {
    
#if !defined (_BIOSIM_IDL_STRINGLIST_CH_)
#define _BIOSIM_IDL_STRINGLIST_CH_
    
    class StringList;
    class StringList_var;
    
    // *************************************************************
    // StringList
    // *************************************************************
    
    class  StringList : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
    {
    public:
      StringList (void); // default ctor
      StringList (CORBA::ULong max); // uses max size
      StringList (
          CORBA::ULong max, 
          CORBA::ULong length, 
          char * *buffer, 
          CORBA::Boolean release = 0
        );
      StringList (const StringList &); // copy ctor
      ~StringList (void);
      static void _tao_any_destructor (void*);
      
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef StringList_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
      
      
    };
    
#endif /* end #if !defined */
    
    
#if !defined (_BIOSIM_IDL_STRINGLIST___VAR_CH_)
#define _BIOSIM_IDL_STRINGLIST___VAR_CH_
    
    // *************************************************************
    // class biosim::idl::StringList_var
    // *************************************************************
    
    class  StringList_var
    {
    public:
      StringList_var (void);
      StringList_var (StringList *);
      StringList_var (const StringList_var &);
      ~StringList_var (void);
      
      StringList_var &operator= (StringList *);
      StringList_var &operator= (const StringList_var &);
      StringList *operator-> (void);
      const StringList *operator-> (void) const;
      
      operator const StringList &() const;
      operator StringList &();
      operator StringList &() const;
      operator StringList *&(); // variable-size base types only
      
      TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);
      
      // in, inout, out, _retn 
      const StringList &in (void) const;
      StringList &inout (void);
      StringList *&out (void);
      StringList *_retn (void);
      StringList *ptr (void) const;
    
    private:
      StringList *ptr_;
    };
    
    
#endif /* end #if !defined */
    
    
#if !defined (_BIOSIM_IDL_STRINGLIST___OUT_CH_)
#define _BIOSIM_IDL_STRINGLIST___OUT_CH_
    
    class  StringList_out
    {
    public:
      StringList_out (StringList *&);
      StringList_out (StringList_var &);
      StringList_out (const StringList_out &);
      StringList_out &operator= (const StringList_out &);
      StringList_out &operator= (StringList *);
      operator StringList *&();
      StringList *&ptr (void);
      StringList *operator-> (void);
      TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);
    
    private:
      StringList *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const StringList_var &);
    };
    
    
#endif /* end #if !defined */
    
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_StringList;
    
        TAO_NAMESPACE  framework
    {
      
#if !defined (_BIOSIM_IDL_FRAMEWORK_BIODRIVER___PTR_CH_)
#define _BIOSIM_IDL_FRAMEWORK_BIODRIVER___PTR_CH_
      
      class BioDriver;
      typedef BioDriver *BioDriver_ptr;
      
#endif /* end #if !defined */
      
      
#if !defined (_BIOSIM_IDL_FRAMEWORK_BIODRIVER___VAR_CH_)
#define _BIOSIM_IDL_FRAMEWORK_BIODRIVER___VAR_CH_
      
      class  BioDriver_var : public TAO_Base_var
      {
      public:
        BioDriver_var (void); // default constructor
        BioDriver_var (BioDriver_ptr p) : ptr_ (p) {} 
        BioDriver_var (const BioDriver_var &); // copy constructor
        ~BioDriver_var (void); // destructor
        
        BioDriver_var &operator= (BioDriver_ptr);
        BioDriver_var &operator= (const BioDriver_var &);
        BioDriver_ptr operator-> (void) const;
        
        operator const BioDriver_ptr &() const;
        operator BioDriver_ptr &();
        // in, inout, out, _retn 
        BioDriver_ptr in (void) const;
        BioDriver_ptr &inout (void);
        BioDriver_ptr &out (void);
        BioDriver_ptr _retn (void);
        BioDriver_ptr ptr (void) const;
        
        // Hooks used by template sequence and object manager classes
        // for non-defined forward declared interfaces.
        static BioDriver_ptr tao_duplicate (BioDriver_ptr);
        static void tao_release (BioDriver_ptr);
        static BioDriver_ptr tao_nil (void);
        static BioDriver_ptr tao_narrow (
            CORBA::Object *,
            CORBA::Environment &
          );
        static CORBA::Object * tao_upcast (void *);
      
      private:
        BioDriver_ptr ptr_;
        // Unimplemented - prevents widening assignment.
        BioDriver_var (const TAO_Base_var &rhs);
        BioDriver_var &operator= (const TAO_Base_var &rhs);
      };


#endif /* end #if !defined */
      
      
#if !defined (_BIOSIM_IDL_FRAMEWORK_BIODRIVER___OUT_CH_)
#define _BIOSIM_IDL_FRAMEWORK_BIODRIVER___OUT_CH_
      
      class  BioDriver_out
      {
      public:
        BioDriver_out (BioDriver_ptr &);
        BioDriver_out (BioDriver_var &);
        BioDriver_out (const BioDriver_out &);
        BioDriver_out &operator= (const BioDriver_out &);
        BioDriver_out &operator= (const BioDriver_var &);
        BioDriver_out &operator= (BioDriver_ptr);
        operator BioDriver_ptr &();
        BioDriver_ptr &ptr (void);
        BioDriver_ptr operator-> (void);
      
      private:
        BioDriver_ptr &ptr_;
      };
      
      
#endif /* end #if !defined */
      
      
#if !defined (_BIOSIM_IDL_FRAMEWORK_BIODRIVER_CH_)
#define _BIOSIM_IDL_FRAMEWORK_BIODRIVER_CH_
      
      // Forward Classes Declaration.
      class _TAO_BioDriver_Proxy_Impl;
      class _TAO_BioDriver_Remote_Proxy_Impl;
      class _TAO_BioDriver_Proxy_Broker;
      class _TAO_BioDriver_Remote_Proxy_Broker;
      
      class  BioDriver
        : public virtual CORBA_Object
      {
      public:
      #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
        typedef BioDriver_ptr _ptr_type;
        typedef BioDriver_var _var_type;
      #endif /* ! __GNUC__ || g++ >= 2.8 */

        static int _tao_class_id;
        
        // The static operations.
        static BioDriver_ptr _duplicate (BioDriver_ptr obj);
        
        static BioDriver_ptr _narrow (
            CORBA::Object_ptr obj,
            CORBA::Environment &ACE_TRY_ENV = 
              TAO_default_environment ()
          );
        
        static BioDriver_ptr _unchecked_narrow (
            CORBA::Object_ptr obj,
            CORBA::Environment &ACE_TRY_ENV = 
              TAO_default_environment ()
          );
        
        static BioDriver_ptr _nil (void)
          {
            return (BioDriver_ptr)0;
          }
        
        static void _tao_any_destructor (void*);
        
        virtual CORBA::Boolean isPaused (
            
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual CORBA::Boolean isStarted (
            
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void spawnSimulation (
            
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void spawnSimulationTillDead (
            
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void spawnSimulationTillN (
            CORBA::Long nTicks
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void pauseSimulation (
            
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void endSimulation (
            
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual CORBA::Boolean simulationHasStarted (
            
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void advanceOneTick (
            
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void resumeSimulation (
            
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void setLogging (
            CORBA::Boolean pLogSim
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual CORBA::Boolean isLogging (
            
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void setDriverPauseLength (
            CORBA::Long pDriverPauseLength
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual CORBA::Long getDriverPauseLength (
            
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual CORBA::Boolean _is_a (
            const CORBA::Char *type_id, 
            CORBA::Environment &ACE_TRY_ENV = 
              TAO_default_environment ()
          );
        
        virtual void *_tao_QueryInterface (ptr_arith_t type);
        
        virtual const char* _interface_repository_id (void) const;

      private:
        _TAO_BioDriver_Proxy_Broker *the_TAO_BioDriver_Proxy_Broker_;
        
      protected:
        BioDriver (int collocated = 0);
        
        // These methods travese the inheritance tree and set the
        // parents piece of the given class in the right mode
        virtual void biosim_idl_framework_BioDriver_setup_collocation (int collocated);
        
        BioDriver (
            TAO_Stub *objref, 
            CORBA::Boolean _tao_collocated = 0,
            TAO_Abstract_ServantBase *servant = 0
          );
        
        friend class _TAO_BioDriver_Remote_Proxy_Impl;
        friend class _TAO_BioDriver_ThruPOA_Proxy_Impl;
        friend class _TAO_BioDriver_Direct_Proxy_Impl;
        
        virtual ~BioDriver (void);
      
      private:
        BioDriver (const BioDriver &);
        void operator= (const BioDriver &);
      };
      
      // The Proxy Implementations are used by each interface to
      // perform a call. Each different implementation encapsulate
      // an invocation logics.
      
      
      ///////////////////////////////////////////////////////////////////////
      //                    Base Proxy Impl. Declaration
      //
      
      class  _TAO_BioDriver_Proxy_Impl
        : public virtual TAO_Object_Proxy_Impl
      {
      public:
        virtual ~_TAO_BioDriver_Proxy_Impl (void) { }
        virtual CORBA::Boolean isPaused (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual CORBA::Boolean isStarted (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual void spawnSimulation (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual void spawnSimulationTillDead (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual void spawnSimulationTillN (
            CORBA_Object *_collocated_tao_target_,
            CORBA::Long nTicks
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual void pauseSimulation (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual void endSimulation (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual CORBA::Boolean simulationHasStarted (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual void advanceOneTick (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual void resumeSimulation (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual void setLogging (
            CORBA_Object *_collocated_tao_target_,
            CORBA::Boolean pLogSim
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual CORBA::Boolean isLogging (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual void setDriverPauseLength (
            CORBA_Object *_collocated_tao_target_,
            CORBA::Long pDriverPauseLength
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        virtual CORBA::Long getDriverPauseLength (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;
        
        
      protected:
        _TAO_BioDriver_Proxy_Impl (void);
      };
      
      //
      //               End Base Proxy Impl. Declaration
      ///////////////////////////////////////////////////////////////////////
      
      
      ///////////////////////////////////////////////////////////////////////
      //                Remote Proxy Impl. Declaration
      //
      
      class  _TAO_BioDriver_Remote_Proxy_Impl
        : public virtual _TAO_BioDriver_Proxy_Impl,
          public virtual TAO_Remote_Object_Proxy_Impl
      {
      public:
        _TAO_BioDriver_Remote_Proxy_Impl (void);
        
        virtual ~_TAO_BioDriver_Remote_Proxy_Impl (void) { }
        virtual CORBA::Boolean isPaused (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual CORBA::Boolean isStarted (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void spawnSimulation (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void spawnSimulationTillDead (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void spawnSimulationTillN (
            CORBA_Object *_collocated_tao_target_,
            CORBA::Long nTicks
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void pauseSimulation (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void endSimulation (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual CORBA::Boolean simulationHasStarted (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void advanceOneTick (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void resumeSimulation (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void setLogging (
            CORBA_Object *_collocated_tao_target_,
            CORBA::Boolean pLogSim
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual CORBA::Boolean isLogging (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual void setDriverPauseLength (
            CORBA_Object *_collocated_tao_target_,
            CORBA::Long pDriverPauseLength
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        virtual CORBA::Long getDriverPauseLength (
            CORBA_Object *_collocated_tao_target_
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));
        
        
      };
      
      //
      //             End Remote Proxy Impl. Declaration
      ///////////////////////////////////////////////////////////////////////
      
      // The Proxy Brokers are used by each interface to get
      // the right proxy for performing a call. In the new 
      // collocation scheme, the proxy to be used can vary on
      // a call by call basis.
      
      
      ///////////////////////////////////////////////////////////////////////
      //                 Base Proxy Broker Declaration 
      //
      
            class  _TAO_BioDriver_Proxy_Broker
      {
      public:
        virtual ~_TAO_BioDriver_Proxy_Broker (void);
        virtual _TAO_BioDriver_Proxy_Impl &select_proxy (
            BioDriver *object,
            CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
          ) = 0;
        
      protected:
        _TAO_BioDriver_Proxy_Broker (void);
        
      };
      
      //
      //              End Base Proxy Broker Declaration 
      ///////////////////////////////////////////////////////////////////////
      
            
      ///////////////////////////////////////////////////////////////////////
      //                 Remote Proxy Broker Declaration 
      //
      
      class  _TAO_BioDriver_Remote_Proxy_Broker
        : public virtual _TAO_BioDriver_Proxy_Broker
      {
      public: 
        _TAO_BioDriver_Remote_Proxy_Broker (void);
        
        virtual ~_TAO_BioDriver_Remote_Proxy_Broker (void);
        
        virtual _TAO_BioDriver_Proxy_Impl &select_proxy (
            BioDriver *object,
            CORBA_Environment &ACE_TRY_ENV
          );
        
      private:
        _TAO_BioDriver_Remote_Proxy_Impl remote_proxy_impl_;
      
      public:
        // This member function is used to get an handle to the unique instance
        // of the Remote Proxy Broker that is available for a given
        // interface.
        static _TAO_BioDriver_Remote_Proxy_Broker *the_TAO_BioDriver_Remote_Proxy_Broker (void);
      };
      
      //
      //              End Remote Proxy Broker Declaration 
      ///////////////////////////////////////////////////////////////////////
      
      
#endif /* end #if !defined */
      
      TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_BioDriver;
      
      
    }
TAO_NAMESPACE_CLOSE // module biosim::idl::framework


  }
TAO_NAMESPACE_CLOSE // module biosim::idl


}
TAO_NAMESPACE_CLOSE // module biosim

// Proxy Broker Factory function pointer declarations.

extern 
biosim::idl::framework::_TAO_BioDriver_Proxy_Broker *
(*biosim_idl_framework__TAO_BioDriver_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

 void operator<<= (CORBA::Any &, const biosim::idl::StringList &); // copying version
 void operator<<= (CORBA::Any &, biosim::idl::StringList*); // noncopying version
 CORBA::Boolean operator>>= (const CORBA::Any &, biosim::idl::StringList *&); // deprecated
 CORBA::Boolean operator>>= (const CORBA::Any &, const biosim::idl::StringList *&);
// Any operators for interface biosim::idl::framework::BioDriver
 void operator<<= (CORBA::Any &, biosim::idl::framework::BioDriver_ptr);
 CORBA::Boolean operator>>= (const CORBA::Any &, biosim::idl::framework::BioDriver *&);

#ifndef __ACE_INLINE__


#if !defined _TAO_CDR_OP_biosim_idl_StringList_H_
#define _TAO_CDR_OP_biosim_idl_StringList_H_

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const biosim::idl::StringList &
  );
 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    biosim::idl::StringList &
  );

#endif /* _TAO_CDR_OP_biosim_idl_StringList_H_ */

 CORBA::Boolean operator<< (TAO_OutputCDR &, const biosim::idl::framework::BioDriver_ptr );
 CORBA::Boolean operator>> (TAO_InputCDR &, biosim::idl::framework::BioDriver_ptr &);

#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "biosimC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option pop
#endif /* __BORLANDC__ */

#endif /* ifndef */
