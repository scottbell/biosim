\documentstyle{report}

\input epsf

%\nofiles

\setlength{\textheight}{9.0in}
\setlength{\textwidth}{6.5in}
\setlength{\footheight}{0.0in}
\setlength{\topmargin}{0.00in}
\setlength{\headheight}{0.0in}
\setlength{\headsep}{0.0in}
\setlength{\oddsidemargin}{-0.0in}

\makeindex

\begin{document}

\def\topfraction{1.0}        %maximum fraction of floats at the top of the page
\def\bottomfraction{1.0}     %ditto, for the bottom of the page
\def\textfraction{0}         %minimum fraction of text (--> 100% floats is okay)
\def\floatpagefraction{1.0}  % if a page is full of floats, it'd better be FULL

\newcommand{\insertfigure}[2]{\begin{center}
                             \ \epsfxsize=#2 \epsfbox{#1.ps}
                             \end{center}}

%\newcommand{\insertfigure}[2]{\vspace{#2}}

\title{BioSim: An Integrated Simulation of an Advanced Life Support System for Intelligent Control Research\\
Users Manual}

\author{Metrica Inc. and S\&K Technologies\\
NASA Johnson Space Center/ER2\\
Houston TX 77058\\
http://www.traclabs.com/biosim}


\date{\today}

\maketitle

\tableofcontents

\newpage

\listoffigures

\newpage

\chapter{Introduction}

This document describes a simulation of an advanced life support
system as envisioned for future human missions to Mars.  The purpose
of this simulation is to provide a testbed for researchers studying
advanced control of life support systems.  The simulation allows
access to various control parameters of the system.  The simulation
also allows for insertion of malfunctions and stochastic processes.  A
logging facility and a graphical user interface are provided as
services.  The simulation is written in Java and is distributed using
the Common Object Request Broker Architecture (CORBA)\index{CORBA}.
CORBA is also used to interface to the simulation.  The distributed
nature of the simulation allows for multiple instances to be run in
parallel, making it ideal for testing advanced control concepts such
as genetic algorithms or reinforcement learning, which require
multiple trials.  See \cite{kortenkamp_etal01} or
\cite{schreckenghost_etal02} for a background on advanced life support
control issues.  This document begins with a brief introduction to
advanced life support systems.  Then it provides details on
installing, running and interacting with the simulation.  The
simulation is available from http://www.traclabs.com/biosim.

\chapter{Background on advanced life support}

An advanced life support system is one in which many resources are
reused or regenerated.  Such systems will be necessary for long
duration human missions, such as those to Mars, where resupply
opportunities are limited.  Typically they have thin margins for mass,
energy and buffers, which requires optimization and tight control.
Also, advanced life support systems consist of many interconnected
subsystems all of whom interact in both predictable and unpredictable
ways (see Figure~\ref{fig:biosim}).  Autonomous control\index{control}
of these systems is desirable. This section gives enough background so
that users of the simulation can understand the control issues.  For
detailed documentation on advanced life support systems see
\cite{tri99} or go to: http://advlifesupport.jsc.nasa.gov

\begin{figure}
\insertfigure{figure}{5.5in}
\caption{The various modules that comprise the BIOSim integrated simulation.}
\label{fig:biosim}
\end{figure}

\section{Modules}

An advanced life support system consists of many interacting
subsystems.  While each is self-contained, they rely on each other for
various resources.  The simulation is built from a set of modules that
each produce and consume different resources.

\subsection{Environment}
\label{sec:env}
An environment\index{environment} contains air that is consumed by
either people or crops.  Air\index{air} contains a mixture of gases --
in our simulation these gases are oxygen (O2), carbon dioxide (CO2),
nitrogen (N) and water vapor (H20).  The initial composition of the
gases is set by the simulation init file (see
Section~\ref{sec:init}).  As the simulation runs modules may consume
air from the simulation and replace it with air of a different
composition.  Thus, the composition of gases in the air changes over
time and can be measured by environment sensors
(Section~\ref{sec:env_sen}).  As with all modules, there can be
multiple environments.  For example, it is common for crew members
and crops to have different air compositions and that is the default
in this simulation.   

\subsection{Crew}
\label{sec:crew}

The crew\index{crew} module is implemented using models described in
\cite{goudarzi_ting99}.  The number, gender, age and weight of the
crew are settable as input parameters -- in the default configuration
there are four crew members, two male and two female.  The crew cycles
through a set of activities (sleep, maintenance, recreation, etc.).
As they do so they consume O2, food and water and produce CO2, dirty
water and solid waste.  The amount of resources consumed and produced
varies according to crew member attributes and their activities.  The
crew’s activities can be adjusted by passing a new crew schedule to
the crew module.  A default schedule can also be used.  The crew
module is connected to a crew environment that contains an atmosphere
that they breathe.  The initial size and gas composition (percentages
of O2, CO2, H2O and inert gases) are input parameters and the default
is $1.54893 x 10^6 liters$ (from \cite{tri99}) with an atmosphere
equivalent to sea level air.  As the simulation progresses the mixture
of gases in the atmosphere changes.

\subsection{Water}
\label{sec:water}

The water\index{water} recovery module consumes dirty water and
produces potable and grey water (i.e., water that can be used for
washing but not drinking).  The water recovery module consists of four
subsystems that process the water.  The biological water processing
(BWP) subsystem removes organic compounds.  Then the water passes to a
reverse osmosis (RO) subsystem, which makes 85\% of the water passing
through it grey.  The 15\% of water remaining from the RO (called
brine) is passed to the air evaporation subsystem (AES), which
recovers the rest.  These two streams of grey water (from the RO and
the AES) are passed through a post-processing subsystem (PPS) to
create potable water.  An external controller can turn on or off
various subsystems.  For example, all water can pass through the AES
at a higher energy cost.  We based our water recovery module on a
recently completed test at NASA Johnson Space Center
\cite{bonasso_etal03}.


\subsection{Air}
\label{sec:air}

The air\index{air} component takes in exhalant CO2 and produces O2 as long as
there is sufficient energy being provided to the system.  This
component is modeled on various Air Revitalization System (ARS) work
at NASA JSC \cite{malin_etal00}.  There are three interacting air
subsystems: the Variable Configuration Carbon Dioxide Removal (VCCR)
System in which CO2 is removed from the air stream; the Carbon Dioxide
Reduction System (CRS), which also removes CO2 from the air stream
using a different process and producing different gases than the VCCR;
and the Oxygen Generation System (OGS) in which O2 is added to the air
stream by breaking water down into hydrogen and oxygen.  It is
important to note that both the removal of CO2 and the addition of O2
are required for human survival.  It is also important to note that
the biomass component (next subsection) also removes CO2 and adds O2.

\subsection{Biomass}
\label{sec:biomass}

The biomass\index{biomass} component is where crops\index{crops} are
grown.  It produces both biomass, which can be turned into
food\index{food}, and O2 and consumes water, energy (light) and CO2.
This component is based on models given in \cite{jones_cavazzoni00}.
The system is modeled as shelves\index{shelves} that contain plants,
lights and water.  Shelves are planted and harvested and there is
growth cycle for each shelf.  Currently, ten crops are modeled and can
be planted in any ratio.

\subsection{Food processing}
\label{sec:food}

Before biomass can be consumed by the crew it must be converted to
food\index{food}.  The food processing component takes biomass, energy and crew
time and produces food and solid waste.  The crew needs to be involved
in this process as it is labor intensive.  See Section~\ref{sec:crew}
for more information on scheduling crew activities.

\subsection{Waste}
\label{sec:waste}

The waste\index{waste} component consumes energy, O2 and solid waste
and produces CO2.  It is modeled on an incinerator used in the Phase
III test in 1997 \cite{schreckenghost_etal02}.  Incineration can be
scheduled.

\subsection{Thermal control}
\label{sec:thermal}

The thermal control\index{thermal} component regulates the air temperature in the
habitat.  This component is not implemented for this simulation and it
is assumed that external controllers are maintaining chamber
temperature.

\subsection{Energy}
\label{sec:energy}

The energy\index{energy} component supplies power to all of the other
components that need it.  There are two choices for power in the
simulation.  The first is nuclear\index{nuclear} power, which supplies
a fixed amount throughout the lifetime of the simulation.  The second
is solar\index{solar} power, which supplies a varying amount
(day/night cycle) of power to each component.

\subsection{Accumulators}
\label{sec:accumulator}
Scott -- not sure if we need this section.


\chapter{Simulation properties}

The simulation implements the modules outlined in the previous
section.  These are implemented in a producer/consumer relationship,
which is described in the next subsection.  The simulation also
provides additional functionality to help test and debug control
programs.  

\section{Producer/consumer model}

Talk about what this is.  How the simulation works in generic sense
(ticks, transfer of resources, etc.).

\section{Success criteria}

In order to compare different control approaches there should be
objective criteria for a successful advanced life support system
mission.  Several possibilities exist already in the simulation.  For
example, the length of the mission before consumables are gone is a
success criterion.  As is minimizing the starting levels of stores or
minimizing the sizes of intermediary buffers.  However, many of these
fail to get at the true success of a mission, the productivity of the
crew in performing their science objectives.  Thus, the simulation
includes an artificial productivity\index{productivity} measure.  As
the crew cycles through their activities (see Section~\ref{sec:activities})
the amount of time they spend doing science tasks is accumulated. This
number is also multiplied by a factor that takes into account the
amount of sleep, exercise, water, food and oxygen they are getting.
So each tick, for each crew member the productivity is given by the
following equation:

        [need to put the equation here]

\section{Stochastic processes}

Any sufficiently complex process, especially one with biological
components, will not be deterministic\index{deterministic}.  That is,
given the same starting conditions and inputs it will not produce the
exact same outputs each time it is run.  A
stochastic\index{stochastic} process is one in which chance or
probability affect the outcome.  This simulation offers both
deterministic and stochastic operations.  In the former case, running
the simulation twice with the same inputs and initial conditions will
produce the same results.  This may be useful for quantitatively
comparing different control approaches against each other.  In the
latter case, the user can control the amount of variability in the
simulation (see Section 7.4).  This is modeled using a Gaussian\index{Gaussian}
distribution [[Scott fill this in more]].  This can be used to test a
control system’s ability to deal with stochastic processes.

\section{Malfunctions}

The simulation also has the ability to accept
malfunction\index{malfunctions} requests (see Section 7.5).  These
requests will change the operating regime of the simulation.  For
example, by causing a crew member to be sick, energy supplies to drop,
water to leak, plants to die, etc.  Different modules will have
different sensitivities, for example once plants die they cannot
recover, but if the water module is damaged and then repaired it will
operate normally.  Of course, if levels of CO2, water or food reach
hard-coded critical levels the crew will abandon the mission and return
home.

\section{Crew activity scheduling}
\label{sec:activities}
Crew members in an advanced life support system do not just consume
and produce -- they do activities.  These may be science, maintenance,
exercise, sleep, etc.  The following diagram shows the nominal daily
routine for a crew member:

[[Scott, little transition diagram here]]

\section{Mass balance}
What is this?  Why is it important?  How did we do it? 


\chapter{Simulation implementation}

All of the simulation components are written in Java\index{Java} to
make the simulation portable.  Each component is its own
CORBA\index{CORBA} server so that they can be distributed across
computers for increased performance.  We have tested the simulation on
Windows\index{Windows}, Unix\index{Unix} and
Macintosh\index{Macintosh} computers.  A user interface allows for
insight into the simulation.  There is also a logging\index{logging}
facility that will automatically save all simulation values to a file
or a database.  We have Java and C++\index{C++} interfaces to the simulation.

Explain object oriented methodology and how it relates to BioSim.
Would a figure be good here showing the relationship between servers,
clients, CORBA, etc.?

\chapter{Installing the simulation}
The simulation is written in Java and can run on most popular
operating systems.  We provide both an executable for Windows and
source code for any operating system.  This chapter deals with
installing the code onto your computer. 

\section{Installing an executable}

An executable that will run under most Windows operating systems is
available.  You can ownload the Windows executable from: {\tt
  www.traclabs.com/biosim}.

At that site, go to Download and then download the Windows
installer\index{installation}.  Remember where you put it.
Double-click on the Setup.exe icon, accept the agreement, choose the
default installation, install it where you desire and then click
``Finish''.  BIOSim will start automatically.  NOTE: If you do not
have Java\index{Java} installed on your PC then the installer will
direct you to the WWW page to download it (free).  Please e-mail Scott
Bell (scott@traclabs.com) if you have trouble with installing the
simulation.

\begin{figure}
\insertfigure{labelled_interface}{5.5in}
\caption{BioSim’s graphical user interface.}
\label{fig:empty_interface}
\end{figure}

\section{Installing source code}

Scott -- I'll need your help here.

\chapter{Running the simulation}

When BIOSim starts you’ll see a blank interface\index{interface} as shown in
Figure~\ref{fig:empty_interface}.  Holding your mouse over the buttons
on the top reveals what they do.  As noted in the figure, the first
three buttons control the simulation.  The next series of buttons will
display various subsystem views. Some of the views, like the crew, do
not contain anything until the simulation is started.  I like to open
up the main subsystem views before starting the simulation.

The open interface is shown in Figure~\ref{fig:full_interface}.  The
view can be changed between text, chart and schematic by clicking on
the tabs.  The simulation will run until resources (air, water, food,
etc.) drop below critical levels.  Then the simulation will stop.
Pressing the start button will restart the simulation from the
beginning.  If you want to examine the interfaces closely press the
``Pause'' button or go through the simulation one step at a time.

\begin{figure}
\insertfigure{open_interface}{5.5in}
\caption{A full view of BioSim’s graphical user interface}
\label{fig:full_interface}
\end{figure}

\chapter{Controlling the simulation}

The previous chapter showed you how to run BioSim and monitor its
internal state via a graphical user interface.  While interesting,
this is not useful for control system research.  This chapter will
show you how to connect an external control program to BioSim and
change its underlying operation.  Note that this will not be an
exhaustive list of all of the objects and methods in BioSim, but only
the most important for new users.  Complete documentation of all
objects and method calls is available at:
http://www.traclabs.com/biosim/doc/api/index.html

\section{CORBA, Orbs and namesevers}

External control programs connect to BioSim via CORBA\index{CORBA} --
the Common Object Request Broker Architecture.  In order to connect to
BioSim will you will need to install an Object Request Broker
(ORB)\index{ORB} on your machine.  If you are using Java an Orb is
built in.  When the BioSim server is started it registers with a
nameserver\index{nameserver}, which tells client programs where to
find it.  You will need to initialize the Orb and connect to the
nameserver in your external control program before calling BioSim
methods.  This users manual will not cover these details.  We refer
you to any book on CORBA for your language or look at the sample
programs in Appendix A and B.  The rest of this manual assumes that
you are already connected to the Orb and to the nameserver.    
   
\section{Initial conditions}
\label{sec:init}
BioSim is almost infinitely reconfigurable\index{recongifuration} --
from the number of crew members to the size and number of the
different modules.  The start-up configuration of BioSim is controlled
by an eXtensible Markup Language (XML)\index{XML} file that is read in
during BioSim initialization.  If you want to change BioSim's
configuration you need to change the XML file.  The default XML file
is located in:

\begin{verbatim}
   $BIOSIM_HOME/resources/biosim/server/framework/DefaultInitialization.xml
\end{verbatim}

\noindent where {\tt \$BIOSIM\_HOME} is the directory where you installed
BioSim.

You can copy this file, change it's name, modify it and then give its
full path name as a parameter to BioSim on startup to use a different
configuration.  The flag when you start BioSim is {\tt -xml} followed
by the full path name of the XML file.  

\subsection{XML file format}

Explain XML\index{XML} file, how it’s used, how it’s read in. Capacities, levels,
logging, etc.  Malfunctions, crew schedule, resupply, etc.  Attach an
example XML file as an appendix.  Also talk about producer/consumer
relationship again. 

\subsection{Initializing BioSim}

Talk about alternative initialization\index{initialization} via an
API.  Again, capacities, levels, logging, etc. can be set from here.

\begin{figure}
\insertfigure{controller}{4.0in}
\caption{Interaction with the simulation.}
\label{fig:controller}
\end{figure}

\section{Running the simulation}
Figure~\ref{fig:controller} shows the basic control strategy for the
simulation.  The simulation models represent the underlying equations
that govern the producer/consumer relationships (see
Section~\ref{sec:pc}).  Sensors and actuators are provided to access
the underlying simulations.  The user is responsible for writing the
controller, which uses the sensors and actuators to control the
simulation.  The user can also inject malfunctions into the underlying
simulation models and resupply consumables.   

\section{Controlling the simulation}
The root class of the simulation is the {\tt BioDriver} class, which
contains the methods used to control the simulation.  The basic
control unit is a {\bf tick}\index{tick}, which advances the
simulation exactly one hour.  After creating your own BioDriver the
following methods are available:

\begin{enumerate}
\item  {\tt void advanceOneTick()}: Moves all modules of the
  simulation ahead exactly one hour.
\item {\tt void endSimulation()}: Ends\index{end} the simulation entirely.
\item {\tt boolean isDone()}: \index{isDone} Returns true if the simulation has met
  an end condition and has stopped.
\item {\tt void reset() }:\index{reset} Returns the simulation to its initial
  state.
\end{enumerate}

Here's an example of using one of these methods after a BioDriver
class has been created in a Java program:

\begin{verbatim}

    myBioDriver.advanceOneTick();

\end{verbatim}

There are a number of other methods available in the BioDriver class
that are less commonly used than those listed above.  These are
available via the JavaDoc\index{JavaDoc} facility.  After you have
installed your source code you can make documentation via the {\tt
  make-docs.sh} (for Linux) or {\tt make-docs} (for Windows)
executables in the {\tt bin} directory.  The BioDriverImpl class is
under the biosim.server.framework package.

\section{Controlling the modules via sensors and actuators}

\subsection{Generic Sensors}

Sensors\index{sensors} are objects that connect to the underlying
simulation.  Each module has its own set of sensor objects, but they
all inherit the same method calls.  These method calls are:

\begin{itemize}

        \item {\tt getMax:} Returns the maximum allowed value of the sensor
        \item {\tt getMin:} Returns the minimum allowed value of the sensor
        \item {\tt getValue}: Returns the current setting of the sensor
\end{itemize}


\subsection{Additional sensor methods}

Several other generic methods related to sensor noise, malfunctions
and logging are available:

In addition, there will be some sensor-specific methods, which we will discuss with the appropriate sensor.

\section{Generic Actuators}

Actuators\index{actuators} are objects that connect to the underlying simulation.  Each
module has its own set of actuator objects, but they all inherit the
same method calls.  These method calls are:

\begin{itemize}

        \item {\tt getMax}: Returns the maximum allowed value of the actuator
        \item {\tt getMin}: Returns the minimum allowed value of the actuator
        \item {\tt getValue}: Returns the current value of the actuator       
        \item {\tt setValue}: Sets the actuator

\end{itemize}

\subsection{Additional actuator methods}

Several other generic methods related to actuator noise, malfunctions
and logging are available:

In addition, there will be some actuator-specific methods, which we
will discuss with the appropriate actuator.


\subsection{Environments}

Environments\index{environment} contain the air\index{air} that crew
and crops use.  There can be multiple environments in the simulation,
but they are all controlled by the same sensors and actuators.

\subsubsection{Sensors}
\label{sec:env_sen}
The following sensors are available in the environment:

\begin{enumerate}

\item {\tt AirInFlowRateSensor}: Flow rate in moles/tick of air into the environment
\item {\tt AirOutFlowRateSensor}: Flow rate in moles/tick of air out of the environment
\item {\tt CO2AirConcentrationSensor}: Amount in ??? of CO2 in the environment.
\item {\tt CO2AirEnvironmentInFlowRateSensor}: Flow rate in liters/tick of CO2 into the environment
\item {\tt CO2AirEnvironmentOutFlowRateSensor}: Flow rate in liters/tick of CO2 out of the environment
\item {\tt CO2AirPressureSensor}: Pressure in ??? of CO2 in the environment
\item {\tt CO2AirStoreInFlowRateSensor}: 
\item {\tt CO2AirStoreOutFlowRateSensor}: 
\item {\tt NitrogenAirConcentrationSensor}: Amount in ??? of Nitrogen in the environment
\item {\tt NitrogenAirEnvironmentInFlowRateSensor}:
\item {\tt NitrogenAirEnvironmentOutFlowRateSensor}:
\item {\tt NitrogenAirPressureSensor}:
\item {\tt NitrogenAirStoreInFlowRateSensor}:
\item {\tt NitrogenAirStoreOutFlowRateSensor}:
\item {\tt O2AirConcentrationSensor}: Amount in ??? of O2 in the environment.
\item {\tt O2AirEnvironmentInFlowRateSensor}: Flow rate in liters/tick of O2 into the environment
\item {\tt O2AirEnvironmentOutFlowRateSensor}: Flow rate in liters/tick of O2 out of the environment
\item {\tt O2AirPressureSensor}: Pressure in ??? of O2 in the environment
\item {\tt O2AirStoreInFlowRateSensor}: 
\item {\tt O2AirStoreOutFlowRateSensor}: 
\item {\tt OtherAirConcentrationSensor}:
\item {\tt OtherAirPressureSensor}:
\item {\tt WaterAirConcentrationSensor}: Amount in ??? of water (humidity) in the environment
\item {\tt WaterAirEnvironmentInFlowRateSensor}:
\item {\tt WaterAirEnvironmentOutFlowRateSensor}:
\item {\tt WaterAirPressureSensor}:
\item {\tt WaterAirStoreInFlowRateSensor}:
\item {\tt WaterAirStoreOutFlowRateSensor}: 
\end{enumerate}

\subsubsection{Actuators}

\begin{enumerate}

\item {\tt AirInFlowRateActuator}: Flow rate in moles/tick of air into the environment
\item {\tt AirOutFlowRateActuator}: Flow rate in moles/tick of air out of the environment
\item {\tt CO2AirConcentrationActuator}: Amount in ??? of CO2 in the environment.
\item {\tt CO2AirEnvironmentInFlowRateActuator}: Flow rate in liters/tick of CO2 into the environment
\item {\tt CO2AirEnvironmentOutFlowRateActuator}: Flow rate in liters/tick of CO2 out of the environment
\item {\tt CO2AirPressureActuator}: Pressure in ??? of CO2 in the environment
\item {\tt CO2AirStoreInFlowRateActuator}: 
\item {\tt CO2AirStoreOutFlowRateActuator}: 
\item {\tt NitrogenAirConcentrationActuator}: Amount in ??? of Nitrogen in the environment
\item {\tt NitrogenAirEnvironmentInFlowRateActuator}:
\item {\tt NitrogenAirEnvironmentOutFlowRateActuator}:
\item {\tt NitrogenAirPressureActuator}:
\item {\tt NitrogenAirStoreInFlowRateActuator}:
\item {\tt NitrogenAirStoreOutFlowRateActuator}:
\item {\tt O2AirConcentrationActuator}: Amount in ??? of O2 in the environment.
\item {\tt O2AirEnvironmentInFlowRateActuator}: Flow rate in liters/tick of O2 into the environment
\item {\tt O2AirEnvironmentOutFlowRateActuator}: Flow rate in liters/tick of O2 out of the environment
\item {\tt O2AirPressureActuator}: Pressure in ??? of O2 in the environment
\item {\tt O2AirStoreInFlowRateActuator}: 
\item {\tt O2AirStoreOutFlowRateActuator}: 
\item {\tt OtherAirConcentrationActuator}:
\item {\tt OtherAirPressureActuator}:
\item {\tt WaterAirConcentrationActuator}: Amount in ??? of water (humidity) in the environment
\item {\tt WaterAirEnvironmentInFlowRateActuator}:
\item {\tt WaterAirEnvironmentOutFlowRateSensor}:
\item {\tt WaterAirPressureActuator}:
\item {\tt WaterAirStoreInFlowRateActuator}:
\item {\tt WaterAirStoreOutFlowRateActuator}: 

\end{enumerate}

\subsubsection{Malfunctions}

State exactly what the malfunctions do.  How do the method calls work.
What is the malfunction. What is the leak rate, etc. for each of the
different malfunction classes.  Since method calls are probably
identical may want to move this up to top and then use this section
only for module-specific malfunction information.

\subsection{Crew}
\index{crew}
\subsubsection{Sensors}

\begin{enumerate}

\item {\tt CrewGroupActivitySensor}:  Returns activity level of crew (average?)
\item {\tt CrewGroupAnyDeadSensor}:
\item {\tt CrewGroupDeathSensor}:
\item {\tt CrewGroupProductivitySensor}:

\end{enumerate}

\subsubsection{Actuators}

\begin{enumerate}

\item {\tt CrewGroupActivityActuator}:

\end{enumerate}

\subsubsection{Malfunctions}

See environment above and supply malfunctions here.


\subsection{Air}
\index{air}
\subsubsection{Sensors}

\begin{enumerate}

\item {\tt CO2InFlowRateSensor}:
\item {\tt CO2OutFlowRateSensor}:
\item {\tt CO2StoreLevelSensor}:
\item {\tt H2InFlowRateSensor}:
\item {\tt H2OutFlowRateSensor}:
\item {\tt H2StoreLevelSensor}:
\item {\tt NitrogenInFlowRateSensor}:
\item {\tt NitrogenOutFlowRateSensor}:
\item {\tt NitrogenStoreLevelSensor}:
\item {\tt O2InFlowRateSensor}:
\item {\tt O2OutFlowRateSensor}:
\item {\tt O2StoreLevelSensor}:

\end{enumerate}

\subsubsection{Actuators}

\begin{enumerate}

\item {\tt CO2InFlowRateSensor}:
\item {\tt CO2OutFlowRateSensor}:
\item {\tt H2InFlowRateSensor}:
\item {\tt H2OutFlowRateSensor}:
\item {\tt NitrogenInFlowRateSensor}:
\item {\tt NitrogenOutFlowRateSensor}:
\item {\tt O2InFlowRateSensor}:
\item {\tt O2OutFlowRateSensor}:

\end{enumerate}

\subsubsection{Malfunctions}

Same as others


\subsection{Water}
\index{water}

\subsubsection{Sensors}
\begin{enumerate}

\item {\tt DirtyWaterInFlowRateSensor}:
\item {\tt DirtyWaterOutFlowRateSensor}:
\item {\tt DirtyWaterStoreLevelSensor}:
\item {\tt GreyWaterInFlowRateSensor}:
\item {\tt GreyWaterOutFlowRateSensor}:
\item {\tt GreyWaterStoreLevelSensor}:
\item {\tt PotableWaterInFlowRateSensor}:
\item {\tt PotableWaterOutFlowRateSensor}:
\item {\tt PotableWaterStoreLevelSensor}:
\end{enumerate}

\subsubsection{Actuators}

\begin{enumerate}

\item {\tt DirtyWaterInFlowRateActuator}:
\item {\tt DirtyWaterOutFlowRateActuator}:
\item {\tt GreyWaterInFlowRateActuator}:
\item {\tt GreyWaterOutFlowRateActuator}:
\item {\tt PotableWaterInFlowRateActuator}:
\item {\tt PotableWaterOutFlowRateActuator}:
\end{enumerate}

\subsubsection{Malfunctions}

\subsection{Biomass}
\index{biomass}

\subsubsection{Sensors}

\subsubsection{Actuators}

\subsubsection{Malfunctions}

\subsection{Solid Waste}
\index{waste}

\subsubsection{Sensors}

\subsubsection{Actuators}

\subsubsection{Malfunctions}

\subsection{Energy}
\index{energy}

\subsubsection{Sensors}

\begin{enumerate}
\item {\tt PowerInFlowRateSensor}:
\item {\tt PowerOutFlowRateSensor}:
\item {\tt PowerStoreLevelSensor}:
\end{enumerate}

\subsubsection{Actuators}

\begin{enumerate}
\item {\tt PowerInFlowRateActuator}:
\item {\tt PowerOutFlowRateActuator}:
\end{enumerate}

\subsubsection{Malfunctions}

\section{Enabling stochastic processes}

\chapter{Writing a simple Java controller}

A short tutorial on creating a BioSim, initializing it and then
calling some sensors, actuators and ticks.  Assume JacOrb. 

\chapter{Writing a simple C++ controller}

Same as above in C++.  Assume ACEOrb.  Assume Linux (?).

\chapter{Control Examples}

Include GA, Rice learners, Texas Tech learner.

\chapter{Conclusions}

\appendix 
\chapter{Java Example}

\begin{verbatim}

Put parts of Rice handcontroller here

\end{verbatim}

\chapter{C++ Example}

\begin{verbatim}

#include "biosimC.h"
#include <CosNamingC.h>

static const char* CorbaServerName = "BioDriver0";
int
main(int argc,char *argv[])
{
  try {
    // Initialize orb
    CORBA::ORB_var orb = CORBA::ORB_init(argc,argv,"TestClient");

    cerr << "initialized orb" << endl;

    if (argc < 2) {
      cerr << "Usage: " << argv[0]
           << " IOR_string" << endl;
      return 1;
    }

// Use the first argument to create the object reference,
    // in real applications we use the naming service, but let's do
    // the easy part first!

    CORBA::Object_var obj =
      orb->string_to_object (argv[1]); 

    cout << "After resolve_initial_references" << endl;


    /*   CORBA::Object_var obj =
         orb->string_to_object (argv[1]); */
 
    CosNaming::NamingContext_var inc = CosNaming::NamingContext::_narrow(obj);

    cout << "After NameService narrow" << endl;

    if(CORBA::is_nil(inc)) {
      cerr << "Unable to narrow NameService." << endl;
      throw 0;
    }  // end if couldn't get root naming context
    
    CosNaming::Name name;
    name.length(1);
    name[0].id = CORBA::string_dup(CorbaServerName);
    name[0].kind = CORBA::string_dup("");

    CORBA::Object_var tmp = inc->resolve(name);

    cout << "After resolve name" << endl;

    if(CORBA::is_nil(tmp)) {
      cerr << "Unable to resolve " << CorbaServerName << " from NameService" << endl;
      throw 0;
    }  // end if couldn't find object

    cerr << "got object" << endl;

    // Now downcast the object reference to the appropriate type

    biosim::idl::framework::BioDriver_var biodriver = biosim::idl::framework::BioDriver::_narrow(tmp);


    cerr << "narrowed" << endl;

    // code here

    biodriver->spawnSimulationTillDead();

    cerr << "spawned" << endl;

    orb->destroy ();
  }
  catch (CORBA::Exception &ex) {
    std::cerr << "CORBA exception raised! " << std::endl;
  }
  return 0;
}

\end{verbatim}

\bibliography{biosim}
\bibliographystyle{plain}

\begin{theindex}

\input{users_manual.ind}

\end{theindex}


\end{document}

