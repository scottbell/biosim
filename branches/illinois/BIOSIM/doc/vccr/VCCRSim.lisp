;;;; -*- Mode: LISP; Syntax: ANSI-COMMON-LISP; Package: CL-USER -*-;; The VCCR simple sim for RAPs development;; This file consists of three parts: a progn which creates the objects and the pipelines;; of the vccr, a  of functions that serve as the simulation of the vccr, and;; a set of functions that serve as the data interface to the physical vccr for grafx updating in lieu;; of the sim.#+mcl(in-package :cl-user);; The taxonomy of the eclss components is in eclssClasses.lisp;;;;;***********************************************************;;;;;The instantiation of the VCCR system;;;;;------------------------------------------------------------ (progn  (setf *VCCR-objects* nil);; big objects(Pushnew (make-instance 'physical-object :name :vccr-dessicant-bed1)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'physical-object :name :vccr-dessicant-bed2)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'physical-object :name :co2-bed3)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'physical-object :name :co2-bed4)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'physical-object :name :vccr-co2-accumulator)         *VCCR-objects* :test #'equal);; heaters(Pushnew (make-instance 'heater :name :vccr-heater-bed3) *VCCR-objects* :test #'equal)(Pushnew (make-instance 'heater :name :vccr-heater-bed4) *VCCR-objects* :test #'equal);; hx(Pushnew (make-instance 'heat-exchanger :name :vccr-hx)         *VCCR-objects* :test #'equal);; pumps(Pushnew (make-instance 'air-compressor :name :vccr-internal-blower :speed 30.0)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-compressor :name :vccr-vacuum-pump :speed 300.0)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-compressor :name :vccr-accum-pump :speed 300.0)         *VCCR-objects* :test #'equal);; pipes(Pushnew (make-instance 'air-pipe :name 'p0 :current-position '(35 140) :width 50 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p1 :current-position '(55 115) :width 10 :height 45)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p2 :current-position '(65 90) :width 20 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p3 :current-position '(65 190) :width 20 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p4 :current-position '(170 95) :width 90 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p5 :current-position '(170 195) :width 90 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p6 :current-position '(155 125) :width 10 :height 50)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p7 :current-position '(155 175) :width 10 :height 50)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p8 :current-position '(165 140) :width 30 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p9 :current-position '(240 140) :width 30 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p10 :current-position '(300 95) :width 50 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p11 :current-position '(300 195) :width 50 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p12 :current-position '(355 140) :width 120 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p13 :current-position '(420 120) :width 10 :height 45)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p14 :current-position '(420 165) :width 10 :height 45)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p15 :current-position '(405 95) :width 40 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p16 :current-position '(400 185) :width 50 :height 10)         *VCCR-objects* :test #'equal)#|(Pushnew (make-instance 'air-pipe :name 'p17 :current-position '(425 140) :width 50 :height 10)         *VCCR-objects* :test #'equal)|#(Pushnew (make-instance 'air-pipe :name 'p18 :current-position '(465 140) :width 40 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p19 :current-position '(420 80) :width 60 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p20 :current-position '(420 200) :width 60 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p21 :current-position '(450 105) :width 10 :height 60)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p22 :current-position '(450 175) :width 10 :height 60)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p23 :current-position '(485 160) :width 10 :height 40)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p24 :current-position '(550 195) :width 50 :height 10)         *VCCR-objects* :test #'equal)#|(Pushnew (make-instance 'air-pipe :name 'p25 :current-position '(545 205) :width 10 :height 110)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p26 :current-position '(490 215) :width 20 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p27 :current-position '(520 215) :width 40 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p28 :current-position '(560 155) :width 30 :height 10)         *VCCR-objects* :test #'equal)|#(Pushnew (make-instance 'air-pipe :name 'p29 :current-position '(580 315) :width 10 :height 250)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p30 :current-position '(580 180) :width 10 :height 40)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p31 :current-position '(485 110) :width 10 :height 50)         *VCCR-objects* :test #'equal)#|(Pushnew (make-instance 'air-pipe :name 'p32 :current-position '(300 305) :width 495 :height 10)         *VCCR-objects* :test #'equal)|#(Pushnew (make-instance 'air-pipe :name 'p33 :current-position '(55 250) :width 10 :height 120)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p34 :current-position '(30 305) :width 40 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p35 :current-position '(35 90) :width 25 :height 10)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p36 :current-position '(25 195) :width 10 :height 220)         *VCCR-objects* :test #'equal)(Pushnew (make-instance 'air-pipe :name 'p37 :current-position '(55 165) :width 10 :height 45)         *VCCR-objects* :test #'equal)(setf *vccr-pipe-number* 37);; valves(Pushnew (make-instance 'valve :name :vccr-bed1-in) *VCCR-objects* :test #'equal)(Pushnew (make-instance 'valve :name :vccr-bed2-in) *VCCR-objects* :test #'equal)(Pushnew (make-instance 'valve :name :vccr-blower-in) *VCCR-objects* :test #'equal)(Pushnew (make-instance 'valve :name :vccr-bed3-in) *VCCR-objects* :test #'equal)(Pushnew (make-instance 'valve :name :vccr-bed4-in) *VCCR-objects* :test #'equal)(Pushnew (make-instance 'valve :name :vccr-blower-out-bed3) *VCCR-objects* :test #'equal)(Pushnew (make-instance 'valve :name :vccr-blower-out-bed4) *VCCR-objects* :test #'equal)(Pushnew (make-instance 'valve :name :vccr-desorb-bypass) *VCCR-objects* :test #'equal)(Pushnew (make-instance 'valve :name :vccr-vacuum-pump-in) *VCCR-objects* :test #'equal)(Pushnew (make-instance 'valve :name :vccr-vacuum-pump-out) *VCCR-objects* :test #'equal);(Pushnew (make-instance 'valve :name :vccr-evac) *VCCR-objects* :test #'equal);; flowmeters & flow switches;; none;; pressure transducers(Pushnew (make-instance 'pressure-xducer           :name :vccr-xfer-xducer :pressure 0.0            :min-value 0.0 :max-value 50.0 :nominal-value (psig->kPa 6))          *VCCR-objects* :test #'equal)(Pushnew (make-instance 'pressure-xducer           :name :vccr-store-xducer :pressure 0.0           :min-value 0.0 :max-value (psig->kPa 70) :nominal-value (psig->kPa 40))          *VCCR-objects* :test #'equal)(Pushnew (make-instance 'differential-pressure-xducer           :name :vccr-water-xducer :pressure 0.0 :device :vccr           :min-value 0.0 :max-value 10.0 :nominal-value (psig->kPa 0.01))          *VCCR-objects* :test #'equal);; mission sensors(Pushnew (make-instance 'temperature           :name :vccr-input-temp :temperature 0            :min-value (deg-f->c 45) :max-value 100 :nominal-value (deg-f->c 52))          *VCCR-objects* :test #'equal)(Pushnew (make-instance 'temperature           :name :vccr-bed3-temp1 :temperature 0            :min-value (deg-f->c 52) :max-value (deg-f->c 400) :nominal-value (deg-f->c 400))          *VCCR-objects* :test #'equal)(Pushnew (make-instance 'temperature           :name :vccr-bed3-temp2 :temperature 0            :min-value (deg-f->c 52) :max-value (deg-f->c 400) :nominal-value (deg-f->c 400))          *VCCR-objects* :test #'equal)(Pushnew (make-instance 'temperature           :name :vccr-bed3-temp3 :temperature 0            :min-value (deg-f->c 52) :max-value (deg-f->c 400) :nominal-value (deg-f->c 400))          *VCCR-objects* :test #'equal)(Pushnew (make-instance 'temperature           :name :vccr-bed4-temp1 :temperature 0            :min-value (deg-f->c 52) :max-value (deg-f->c 400) :nominal-value (deg-f->c 400))          *VCCR-objects* :test #'equal)(Pushnew (make-instance 'temperature           :name :vccr-bed4-temp2 :temperature 0            :min-value (deg-f->c 52) :max-value (deg-f->c 400) :nominal-value (deg-f->c 400))          *VCCR-objects* :test #'equal)(Pushnew (make-instance 'temperature           :name :vccr-bed4-temp3 :temperature 0            :min-value (deg-f->c 52) :max-value (deg-f->c 400) :nominal-value (deg-f->c 400))          *VCCR-objects* :test #'equal)(Pushnew (make-instance 'temperature           :name :vccr-blower-input-temp :temperature 0            :min-value (deg-f->c 45) :max-value (deg-f->c 400) :nominal-value (deg-f->c 80))          *VCCR-objects* :test #'equal)(Pushnew (make-instance 'temperature           :name :vccr-hx-output-temp :temperature 0            :min-value (deg-f->c 45) :max-value 100 :nominal-value (deg-f->c 52))          *VCCR-objects* :test #'equal);; Gas Sensor (CO2);; 1000.0 ppm = 0.1 %;; 0.5% = OK, 0.6 - 0.8 % = NG(Pushnew (make-instance 'sensor           :name :vccr-cabin-co2            :min-value 0 :max-value 10000 :nominal-value 4500)          *VCCR-objects* :test #'equal)(setf *VCCR-objects* (sort-pipes-in-front *VCCR-objects*));(view-draw-contents *vccr-display*));;;;;***********************************************************;;;;;VCCR SIM;;;;;------------------------------------------------------------;; There are three central functions and an association list.;; The first function, initialize-VCCR-sim, is an initialization function. ;; The association list, *vccr-objects-in-paths*,is the data structure which;; describes the key flow paths that make up the vccr.;; The second function, update-vccr-path takes a path name and the associated data for that path;; and updates the pipe contents and the states of the objects on that path.;; The third function, update-VCCR-sim, continuously loops through all the paths calling update-vccr-path,;; thus causing the simulation.;; On the mac, update-vccr-path also calls update-vccr-path-display;; which updates the vccr grafx display.;; initializing the sim(defun initialize-VCCR-sim ()"Initializes all devices off, all pipes clear and all sensorsto their minimum values."#+mcl(setf *current-eclss-display* *vccr-display*)  (setf *vaccuum-or-accum-pump-on* nil)  (setf *bed-states* '(nil empty) *hc1* nil *hc2* nil)  (loop for o in *VCCR-objects*        do        (let* ((class-name (class-name (class-of o)))               (superclass-names (all-superclass-names class-name)));; turn all pumps & things off          (cond ((eq class-name 'heater)                 (turn o 'off))                ((eq class-name 'heat-exchanger)                 (turn o 'off))                ((member 'pump superclass-names)                 (turn o 'off));; clear all pipes                ((member 'pipe superclass-names)                 (setf (material-in? o) nil));; off desorb valves                ((member (name o) '(:vccr-desorb-bypass :vccr-blower-out-bed3 :vccr-blower-out-bed4))                 (turn o 'off));; close all valves except :vccr-vacuum-pump-in;; because of the space vacuum                ((and (not (eq (name o) :vccr-vacuum-pump-in))                      (eq class-name 'valve))                 (turn o 'closed))                ((eq (name o) :vccr-vacuum-pump-in)                 (turn o 'open));; set all sensors to min-value                ((and (member 'sensor superclass-names)                      (not (member 'flow-switch superclass-names)))                 (case (class-name (class-of o))                   ((pressure-xducer differential-pressure-xducer)                    (setf (pressure o) (min-value o)))                   (temperature (setf (temperature o) (min-value o)))                   (otherwise (setf (cur-value o) (min-value o)))))                )))#+mcl  (initialize-subsystem-sim-display *vccr-objects* *vccr-display*)  );; (initialize-VCCR-sim)                ;; The a-list for the paths of the vccr;; For each path, there are optionally:;;  - an actuator element such as a pump or a heater;;  - a list of valves that should be open if this path;;    is to experience flow;;  - a list of valves that should be closed if this path;;    is to experience flow;;  - a list of valves that should be off if this path is;;    to experience flow;;  - a list of pipes in this path;;  - a list of pipes that should not have flow (anti-path) if;;    this path is experiencing flow;;  - a list of pressure sensors (ps) that should be updated on this path;;  - a list of mission sensors (ms) (TCs, qual monitors, etc.) that should be updated on this path;;  - a list of global variables that must be true (depends on) before this;;    path can experience flow;;  - a list of global variables which should be set true if this;;    path is experiencing flow (global-if-ok) , with this and depends-on;;    we link activities across paths(defparameter *vaccuum-or-accum-pump-on* nil "needed for the vccr sim logic")(defparameter *hc1* nil "needed for the vccr sim logic")(defparameter *hc2* nil "needed for the vccr sim logic")(defparameter *vccr-objects-in-paths*  '((hc1 hc1-air-save hc1-desorb hc2 hc2-air-save hc2-desorb accum ovbd-vent ;         evac         )    (hc1 (pump :vccr-internal-blower on)         (open-valves :vccr-bed1-in :vccr-blower-in :vccr-bed4-in :vccr-blower-out-bed4)         (closed-valves :vccr-bed2-in :vccr-bed3-in :vccr-blower-out-bed3)         (path (p0 p1 p2 p4 p6 p8 p9 p12 p14 p16 p11 p5 p3 p33 p34))         (ms (:vccr-input-temp :vccr-blower-input-temp :vccr-hx-output-temp))         (anti-path (p0 p1 p3 p5 p7 p8 p9 p12 p10 p13 p15 p4 p2 p35 p36 p37))         (global-if-ok *hc1*))    (hc2 (pump :vccr-internal-blower on)         (open-valves :vccr-bed2-in :vccr-bed3-in :vccr-blower-out-bed3)         (closed-valves :vccr-bed1-in :vccr-blower-in :vccr-bed4-in :vccr-blower-out-bed4)         (path (p0 p37 p3 p5 p7 p8 p9 p12 p13 p15 p10 p4 p2 p35 p36))         (ms (:vccr-input-temp :vccr-blower-input-temp :vccr-hx-output-temp))         (anti-path (p1 p2 p4 p6 p8 p9 p12 p11 p14 p16 p5 p3 p33))         (global-if-ok *hc2*))    (hc1-desorb (heater :vccr-heater-bed3)                (open-valves :vccr-desorb-bypass)                (path (p19 p21 p18))                (ps :vccr-xfer-xducer)                (anti-path (p20 p22))                (depends-on (*vaccuum-or-accum-pump-on*)))    (hc2-desorb (heater :vccr-heater-bed4)                (closed-valves :vccr-desorb-bypass)                (path (p20 p22 p18))                (ps :vccr-xfer-xducer)                (anti-path (p19 p21))                (depends-on (*vaccuum-or-accum-pump-on*)));; :vccr-vacuum-pump-out doesn't match the skill spec so I reversed it on the next four    (hc1-air-save (pump :vccr-vacuum-pump on)                  (open-valves :vccr-desorb-bypass :vccr-vacuum-pump-in)                  (closed-valves :vccr-vacuum-pump-out)                  (path (p19 p21 p23 p24 p30))                  (anti-path (p20 p22 p29 p31)))    (hc2-air-save (pump :vccr-vacuum-pump on)                  (open-valves :vccr-vacuum-pump-in)                  (closed-valves :vccr-desorb-bypass :vccr-vacuum-pump-out)                  (path (p20 p22 p23 p24 p30))                  (anti-path (p19 p21 p29 p31)))    (accum (pump :vccr-accum-pump on)           (open-valves :vccr-vacuum-pump-in :vccr-vacuum-pump-out)           (closed-valves)           (path (p23 p24 p29))           (ps :vccr-store-xducer)           (anti-path (p31 p30))           (global-if-ok *vaccuum-or-accum-pump-on*)           (ms (:vccr-cabin-co2 :vccr-water-xducer)))    (ovbd-vent (pump space-vacuum on)               (closed-valves :vccr-vacuum-pump-in)               (path (p31))               (anti-path (p23 p24 p29 p30))               (global-if-ok *vaccuum-or-accum-pump-on*))    #|(evac (pump :vccr-vacuum-pump on)          (off-valves :vccr-vacuum-pump-in)          (open-valves :vccr-vacuum-pump-out :vccr-evac)          (path (p23 p24 p26 p25 p27 p28 p29 p30 p32 p34))          (ps :vccr-xfer-xducer :vccr-store-xducer)          (anti-path (p19 p21 p18 p20 p22 p18 p31))          (global-if-ok *vaccuum-or-accum-pump-on*))|#    )  "A list of paths and then an assoc list having for each path the associated pump,valve, flow path pipes,  pressure xducers and mission sensors if any. ")(defparameter *vccr-ts-and-pipes*  '((:vccr-input-temp p0) (:vccr-blower-input-temp p8)    (:vccr-hx-output-temp p12))  "Used to set the temp sensors on the vccr paths.")(defparameter *xfer-press-delta* 10 "Amount to increase or decrease the xfer pressure over time.")(defparameter *bed-states* '(nil nil) "Desorb state of beds 3 (hc1) & 4 (hc2) for xfer pressure logic");; (setf *bed-states* '(nil heating));; (setf *bed-states* '(empty nil));; (setf *bed-states* '(nil empty));; (Setf *hc2* t);; (setf *bed-states* '(decreasing nil));; 5/17/99 I would like to do a better sim job on these beds.;; Formula for adsorb/desorb amount (lbs);; y = 3E-10x**5 + 1E-08x**4 - 5E-06x**3 + 3E-04x**2 - 1.3E-03x + 2.6E-3;; There's something wrong with this formula. It doesn't match the graph;; given by EC. (defun co2-adsorb-desorb-amt (time)  (loop for i from 1 to 6        with term-list = '(-3E-10 1E-08 -5E-06 3E-04 -1.3E-03 2.6E-3)        sum (* (nth (1- i) term-list) (expt time (- 6 i)))));; (co2-adsorb-desorb-amt 30);; (loop for i from 0 to 60 by 5 do (print (list i (co2-adsorb-desorb-amt i))));; Gonna try also to update the met time(defparameter *vccr-met-increment* 6 "Used by update-xfer-pressure to increment the MET")(defun update-xfer-pressure (pobj)  (let* ((bed (if (eq (state (get-object :vccr-desorb-bypass))                      'open) 'bed3 'bed4))         (heater-name (read-from-string (format nil ":vccr-heater-~a" bed)))         (heater-state (state (get-object heater-name)))         (adjust-met? (memory-ask '(reconfig-on pressure))))    (cond (;; We start out with bed states (nil empty). Nil means just finishing adsorbing to it).;; If the hc heater is off and the desorb press is minimum,;; set the desorb press to nominal and call the hc bed full.           (and (not (if *hc1*                         (first *bed-states*)(second *bed-states*)))                (eq heater-state 'off) ;; airsave;                (<= (pressure pobj) (min-value pobj))                )           (update-value pobj (nominal-value pobj) 'pressure t)           (if *hc1*                (setf (first *bed-states*) 'full)               (setf (second *bed-states*) 'full))           (print (list "AT 1st" *bed-states*)));; If the hc bed state is full and the heater is off we're in airsave, so decrease the;; desorb pressure (possibly down to min). If the press is at min, set the hc bed state to empty;; (empty of air). RAPs will switch to desorb (heater on) either with time or by watching the pressure ;; go to min.          ((and (eq (if *hc1*                        (first *bed-states*)(second *bed-states*)) 'full)                (eq heater-state 'off)) ;; airsave           (update-value pobj                          (max (- (pressure pobj) *xfer-press-delta*)                              (min-value pobj)) 'pressure t)           (if adjust-met? (adjust-met *vccr-met-increment*))           (if (<= (pressure pobj)  (min-value pobj))               (if *hc1*                    (setf (first *bed-states*) 'empty)                   (setf (second *bed-states*) 'empty)))           (print (list "AT 2nd" *bed-states*)));; If the hc bed state is empty and the heater is on we're starting desorbing, so increase the;; desorb pressure and set the hc bed state to heating.           ((and (eq (if *hc1*                        (first *bed-states*)(second *bed-states*)) 'empty)                (eq heater-state 'on))           (update-value pobj                          (min (+ (pressure pobj) *xfer-press-delta*)                              (nominal-value pobj)) 'pressure t)           (if adjust-met? (adjust-met *vccr-met-increment*))           (if *hc1*                (setf (first *bed-states*) 'heating)               (setf (second *bed-states*) 'heating))           (print (list "AT 3rd" *bed-states*)));; If the hc bed state is heating and the heater is on we check the pressure. If it is at;; the nominal value we've passed the point where the heating is breaking off more co2 than;; the desorbing so we set the bed state to decreasing. Else we increase the pressure.          ((and (eq (if *hc1*                        (first *bed-states*)(second *bed-states*)) 'heating)                (eq heater-state 'on))           (if (>= (pressure pobj)  (nominal-value pobj))               (if *hc1*                    (setf (first *bed-states*) 'decreasing)                   (setf (second *bed-states*) 'decreasing))               (progn                  (update-value pobj                                (min (+ (pressure pobj) *xfer-press-delta*)                                    (nominal-value pobj)) 'pressure t)               (if adjust-met? (adjust-met *vccr-met-increment*))))           (print (list "AT 4th" *bed-states*)));; Finally, if the hc bed state is decreasing and the heater is on we decrease the pressure. If it is at;; the min value then we're done with the half cycle.           ((and (eq (if *hc1*                        (first *bed-states*)(second *bed-states*)) 'decreasing)                (eq heater-state 'on))           (update-value pobj                          (max (- (pressure pobj) *xfer-press-delta*)                              (min-value pobj)) 'pressure t)           (if adjust-met? (adjust-met *vccr-met-increment*))           (if (<= (pressure pobj)  (min-value pobj))                                   (if *hc1*                    (setf (first *bed-states*) nil)                   (setf (second *bed-states*) nil)))           (print (list "AT 5th" *bed-states*)))          )))(defparameter *vccr-store-xducer-value* (nominal-value (get-object :vccr-store-xducer)))(defparameter *co2-in-accumulator* nil "used by crs sim")(defun update-vccr-path (path-name path-data)  "The path update function. It uses the path data and the states of the devicesto determine if flows are happening in the paths. It then updates the sensorsaccordingly."  (let* (#+mcl(*current-eclss-display* *VCCR-display*)         (pump-object (get-object (second (assoc 'pump path-data))))         (pump (if pump-object pump-object (second (assoc 'pump path-data))))         (pump-status (third (assoc 'pump path-data)))         (heater-object (get-object (second (assoc 'heater path-data))))         (open-valves (rest (assoc 'open-valves path-data)))         (closed-valves (rest (assoc 'closed-valves path-data)))         (off-valves (rest (assoc 'off-valves path-data)))         (pipes (rename-pipes (first (rest (assoc 'path path-data))) '*vccr-objects*))         (anti-pipes (rename-pipes (first (rest (assoc 'anti-path path-data))) '*vccr-objects*))         (ps (rest (assoc 'ps path-data)))         (global-if-ok (second (assoc 'global-if-ok path-data)))         (depends-on (second (assoc 'depends-on path-data)))         (ms (second (assoc 'ms path-data)))         ;; The function all-valves? is defined in the eclssclasses file.         (all-valves-good? (and (all-valves? open-valves 'open)                                (all-valves? closed-valves 'closed)                                (all-valves? off-valves 'off))))    ;;            (break "WHoa nellie!")    ;;    ;; update the pipes -- antipipes clear previous flows    ;;                  -- except for p34 which conflicts with    ;;                  -- evac and blower off        ;; material-in? is used for grafx and for measuring values of the air/water    ;; in the pipe    ;; (if (eq path-name 'hc2-desorb) (break "Whoa!"))    (loop for p in anti-pipes          as pipe-object = (if (eq (first anti-pipes) 'all)                               p                               (get-object p))          if (eq (class-name (class-of pipe-object)) 'air-pipe)          do          (if (and (not (member p pipes))                   (or (not pump)                       (eq pump 'space-vacuum)                       (and pump-object                            (eq (state pump) pump-status)))                   all-valves-good?)              (setf (material-in? pipe-object) nil)))        (loop for p in pipes           as pipe-object = (get-object p)          do          (cond ((and (or (not pump)                          (eq pump 'space-vacuum)                          (and pump-object                               (eq (state pump) pump-status)))                      all-valves-good?)                 (setf (material-in? pipe-object) t))                ((and pump-object                      (not (eq (state pump) pump-status))                      all-valves-good?                      ;; p34 should be on always until we shut the thing down. Only affects grafx display                      (not (eq p (first (rename-pipes '(p34) '*vccr-objects*)))))                 (setf (material-in? pipe-object) nil)))          )        (if global-if-ok        (if (and all-valves-good?                 (or (not pump)                     (eq pump 'external)                     (eq pump 'space-vacuum)                     (and pump-object (eq (state pump-object) 'on)))                 (dependencies-ok depends-on))            (set global-if-ok t)            (set global-if-ok nil)))        ;; Pressure ducers are handled ad hoc for vccr.    ;; The co2 store ducer is measuring the pressure in the co2 accumulator.    ;; The co2 store ducer pressure and the cabin co2 concentration can be manually set    ;; via the mac grafx gui or from an extant source by using update-value (defined in eclssclasses)    ;; with force = t.                    (loop for p in ps          as pobj = (get-object p)          do          (case p             (:vccr-xfer-xducer             (when (or (and *hc1*                            (eq path-name 'hc1-desorb))                       (and *hc2*                            (eq path-name 'hc2-desorb)))               (if (or                     (and (eq (state (get-object :vccr-vacuum-pump-in))                              'closed)) ;; space vacuum                                                   (and (eq (state (get-object :vccr-vacuum-pump)) 'on)                         (eq (state (get-object :vccr-vacuum-pump-in))                              'open))) ;; air save or accumulate                                      (update-xfer-pressure pobj)                   (update-value pobj (min-value pobj) 'pressure))))            (:vccr-store-xducer              (let ((seq-val                     #+mcl(get-seq-value *VCCR-display*                                    (seq (get-object :vccr-store-xducer)))                    #+allegro *vccr-store-xducer-value*))               (if (and (eq (state (get-object :vccr-vacuum-pump-out)) 'open)                        (eq (state (get-object :vccr-vacuum-pump-in)) 'open)                        (eq (state (get-object :vccr-accum-pump)) 'on)                        (or (and *hc1* (first *bed-states*) (not (eq (first *bed-states*) 'empty)))                            (and *hc2* (second *bed-states*) (not (eq (second *bed-states*) 'empty)))))                      (update-value pobj (min (+ seq-val *xfer-press-delta*)                                              (max-value pobj)) 'pressure t)                      (update-value pobj seq-val 'pressure t))                                    (setf  *co2-in-accumulator* (> (pressure pobj) *xfer-press-delta*))))))         ;; Now the mission (temperature) sensors, looking at    ;; the hx TC especially        (case path-name      (accum (loop for m in ms                   as mobj = (get-object m)                   do                   (if (eq m :vccr-cabin-co2)                       (update-value mobj (nominal-value mobj) 'cur-value)                       (update-value mobj (nominal-value mobj) 'pressure))))      (otherwise       (loop for ts in ms             as pipe = (second (assoc ts *vccr-ts-and-pipes*))             as tobj = (get-object ts)             do             (if (material-in? (get-object (first (rename-pipes (list pipe) '*vccr-objects*)))) ;; have to have material in the pipe                 (cond ((and (eq ts :vccr-hx-output-temp)                             (eq (state (get-object :vccr-hx)) 'on))                        (update-value tobj (nominal-value tobj) 'temperature t))                       ((eq ts :vccr-hx-output-temp)                        (update-value tobj                                       (nominal-value                                        (get-object :vccr-blower-input-temp)) 'temperature t))                       ((not (eq ts :vccr-hx-output-temp))                        (update-value tobj (nominal-value tobj) 'temperature)))                 (update-value tobj (min-value tobj) 'temperature t)))))        ;; co2 bed heaters    (if heater-object        (loop for temp in               (if (eq (second (assoc 'heater path-data)) :vccr-heater-bed3)                  '(:vccr-bed3-temp1 :vccr-bed3-temp2 :vccr-bed3-temp3)                  '(:vccr-bed4-temp1 :vccr-bed4-temp2 :vccr-bed4-temp3))              as tobj = (get-object temp)              do              ;;              (break "WHoa nellie!")              (if (eq (state heater-object) 'on)                  (update-value tobj (nominal-value tobj) 'temperature)                  (update-value tobj (min-value tobj) 'temperature t))))    #+mcl(update-vccr-path-display path-name path-data)    ));; (turn (get-object :vccr-bed1-in) 'open)   ;; (turn (get-object :vccr-bed2-in) 'closed);; (turn (get-object :vccr-bed3-in) 'closed)   ;; (turn (get-object :vccr-bed4-in) 'open);; (turn (get-object :vccr-blower-in) 'open)   ;; (turn (get-object :vccr-blower-out-bed3) 'closed)   ;; (turn (get-object :vccr-blower-out-bed4) 'open)   ;; (turn (get-object :vccr-internal-blower) 'on)   ;; (turn (get-object :vccr-internal-blower) 'off)   ;; (update-VCCR-path  'hc1 (rest (assoc 'hc1 (rest *VCCR-objects-in-paths*))));; (turn (get-object :vccr-hx) 'on);; (turn (get-object :vccr-hx) 'off);; (turn (get-object :vccr-desorb-bypass) 'open)   ;; (turn (get-object :vccr-vacuum-pump-in) 'open)   ;; (turn (get-object :vccr-vacuum-pump-out) 'open)   ;; (turn (get-object :vccr-vacuum-pump) 'on)   ;; (turn (get-object :vccr-vacuum-pump) 'off)   ;; (update-VCCR-path (rest (assoc 'hc1-air-save (rest *VCCR-objects-in-paths*))));; (turn (get-object :vccr-vacuum-pump-out) 'closed)   ;; (turn (get-object :vccr-heater-bed3) 'on)   ;; (turn (get-object :vccr-heater-bed3) 'off)   ;; (turn (get-object :vccr-accum-pump) 'on)   ;; (turn (get-object :vccr-accum-pump) 'off)   ;; (update-VCCR-path (rest (assoc 'hc1-desorb (rest *VCCR-objects-in-paths*))));; (update-VCCR-path (rest (assoc 'accum (rest *VCCR-objects-in-paths*))));; (turn (get-object :vccr-vacuum-pump-in) 'closed)   ;; (update-VCCR-path (rest (assoc 'ovbd-vent (rest *VCCR-objects-in-paths*))));; (turn (get-object :vccr-bed4-in) 'closed);; (turn (get-object :vccr-bed3-in) 'open)   ;; (turn (get-object :vccr-bed2-in) 'open)   ;; (turn (get-object :vccr-bed1-in) 'closed)   ;; (turn (get-object :vccr-blower-in) 'closed)   ;; (turn (get-object :vccr-blower-out-bed3) 'open)   ;; (turn (get-object :vccr-blower-out-bed4) 'closed)   ;; (turn (get-object :vccr-internal-blower) 'on)   ;; (update-VCCR-path  (rest (assoc 'hc2 (rest *VCCR-objects-in-paths*))));; (turn (get-object :vccr-desorb-bypass) 'closed)   ;; (turn (get-object :vccr-vacuum-pump-in) 'open)   ;; (turn (get-object :vccr-vacuum-pump-out) 'open)   ;; (turn (get-object :vccr-vacuum-pump) 'on);; (update-VCCR-path  (rest (assoc 'hc2-air-save (rest *VCCR-objects-in-paths*))));; (turn (get-object :vccr-vacuum-pump-out) 'closed);; (turn (get-object :vccr-heater-bed3) 'off)   ;; (turn (get-object :vccr-heater-bed4) 'on)      ;; (turn (get-object :vccr-accum-pump) 'on)   ;; (update-VCCR-path  (rest (assoc 'hc2-desorb (rest *VCCR-objects-in-paths*))));; (update-VCCR-path  (rest (assoc 'accum (rest *VCCR-objects-in-paths*))));; (turn (get-object :vccr-vacuum-pump-in) 'closed)   ;; (update-VCCR-path  (rest (assoc 'ovbd-vent (rest *VCCR-objects-in-paths*))));; (turn (get-object :vccr-internal-blower) 'off)   ;; (turn (get-object :vccr-vacuum-pump-in) 'off);; (turn (get-object :vccr-evac) 'open);; (turn (get-object :vccr-vacuum-pump-out) 'open);; (turn (get-object :vccr-vacuum-pump) 'on)   ;; (turn (get-object :vccr-internal-blower) 'off)   ;; (update-VCCR-path  (rest (assoc 'evac (rest *VCCR-objects-in-paths*))))  ;; This is the main loop sim driver. It is the function that the sim process;; runs when it starts up.(defun update-VCCR-sim ()  "Goes thru the flow paths and calls update-VCCR-path."  (let ((path-names (first *VCCR-objects-in-paths*))        (path-data (rest *VCCR-objects-in-paths*)));    (setf *any-pipes-changed?* (remove 'vccr *any-pipes-changed?*))    (loop for name in path-names          do          (update-VCCR-path name (rest (assoc name path-data))))));; (update-VCCR-sim);;#+mcl (load "ars_Raps:VCCRgrafx")(defparameter *VCCR-process* nil "Process for the VCCR sim.")(defparameter *VCCR-process-delay* 5 "Sleep ticks for the VCCR sim")(defun VCCR-sim-process-function ()  (loop   (update-VCCR-sim)   (sleep *VCCR-process-delay*)));; These next functions manage the sim process from an extant;; gui.#+mcl(defun stop-VCCR-sim ()  (when (member *VCCR-process* *all-processes* :test 'equal)    (process-abort *VCCR-process*)    (format *top-listener* "~% *VCCR-process* stopped.")))(defun start-VCCR-sim ()#+mcl(stop-VCCR-sim)  (initialize-VCCR-sim)#+allegro (VCCR-sim-process-function)#+mcl(setf *VCCR-process*         (process-run-function "VCCR" 'VCCR-sim-process-function)))#+mcl(defun resume-VCCR-sim ()       (stop-VCCR-sim)       (setf *VCCR-process*              (process-run-function "VCCR" 'VCCR-sim-process-function)));;;;;***********************************************************;;;;;VCCR IPC;;;;;------------------------------------------------------------;; When running with actual skills, we use the path data to update a grafx display.;; Values coming from the device skill serve as the data, and the vccr sim objects;; get updated with those values.;; The broadcast message which comes from the vccr device skill.;; The below defstruct is needed for IPC lisp.#+ipc(ipc:ipc_defstruct (vccr);;  (time "" :type string)   (time "" :type int)  (PU01_o1 "" :TYPE STRING)   (VAL_PU01_o1 0 :TYPE integer)   (PU01_i1 "" :TYPE STRING)   (VAL_PU01_i1 0 :TYPE integer)   (PU02_o1 "" :TYPE STRING)   (VAL_PU02_o1 0 :TYPE integer)   (PU02_i1 "" :TYPE STRING)   (VAL_PU02_i1 0 :TYPE integer)   (PU03_o1 "" :TYPE STRING)   (VAL_PU03_o1 0 :TYPE integer)   (PU03_i1 "" :TYPE STRING)   (VAL_PU03_i1 0 :TYPE integer)   (V01_o1 "" :TYPE STRING)   (VAL_V01_o1 0 :TYPE integer)   (V01_o2 "" :TYPE STRING)   (VAL_V01_o2 0 :TYPE integer)   (V01_i1 "" :TYPE STRING)   (VAL_V01_i1 0 :TYPE integer)   (V01_i2 "" :TYPE STRING)   (VAL_V01_i2 0 :TYPE integer)   (V01_i3 "" :TYPE STRING)   (VAL_V01_i3 0 :TYPE integer)   (V02_o1 "" :TYPE STRING)   (VAL_V02_o1 0 :TYPE integer)   (V02_o2 "" :TYPE STRING)   (VAL_V02_o2 0 :TYPE integer)   (V02_i1 "" :TYPE STRING)   (VAL_V02_i1 0 :TYPE integer)   (V02_i2 "" :TYPE STRING)   (VAL_V02_i2 0 :TYPE integer)   (V02_i3 "" :TYPE STRING)   (VAL_V02_i3 0 :TYPE integer)   (V03_o1 "" :TYPE STRING)  (VAL_V03_o1 0 :TYPE integer)   (V03_o2 "" :TYPE STRING)   (VAL_V03_o2 0 :TYPE integer)   (V03_i1 "" :TYPE STRING)   (VAL_V03_i1 0 :TYPE integer)   (V03_i2 "" :TYPE STRING)   (VAL_V03_i2 0 :TYPE integer)   (V03_i3 "" :TYPE STRING)   (VAL_V03_i3 0 :TYPE integer)   (V04_o1 "" :TYPE STRING)   (VAL_V04_o1 0 :TYPE integer)   (V04_i1 "" :TYPE STRING)   (VAL_V04_i1 0 :TYPE integer)   (V05_o1 "" :TYPE STRING)   (VAL_V05_o1 0 :TYPE integer)   (V05_i1 "" :TYPE STRING)   (VAL_V05_i1 0 :TYPE integer)   (V06_o1 "" :TYPE STRING)   (VAL_V06_o1 0 :TYPE integer)   (V06_i1 "" :TYPE STRING)   (VAL_V06_i1 0 :TYPE integer)   (V07_o1 "" :TYPE STRING)   (VAL_V07_o1 0 :TYPE integer)   (V07_i1 "" :TYPE STRING)   (VAL_V07_i1 0 :TYPE integer)   (V08_o1 "" :TYPE STRING)  (VAL_V08_o1 0 :TYPE integer)   (V08_o2 "" :TYPE STRING)   (VAL_V08_o2 0 :TYPE integer)   (V08_i1 "" :TYPE STRING)   (VAL_V08_i1 0 :TYPE integer)   (V08_i2 "" :TYPE STRING)   (VAL_V08_i2 0 :TYPE integer)   (V08_i3 "" :TYPE STRING)   (VAL_V08_i3 0 :TYPE integer)   (V09_o1 "" :TYPE STRING)  (VAL_V09_o1 0 :TYPE integer)   (V09_o2 "" :TYPE STRING)   (VAL_V09_o2 0 :TYPE integer)   (V09_i1 "" :TYPE STRING)   (VAL_V09_i1 0 :TYPE integer)   (V09_i2 "" :TYPE STRING)   (VAL_V09_i2 0 :TYPE integer)   (V09_i3 "" :TYPE STRING)   (VAL_V09_i3 0 :TYPE integer)   (V10_o1 "" :TYPE STRING)  (VAL_V10_o1 0 :TYPE integer)   (V10_o2 "" :TYPE STRING)   (VAL_V10_o2 0 :TYPE integer)   (V10_i1 "" :TYPE STRING)   (VAL_V10_i1 0 :TYPE integer)   (V10_i2 "" :TYPE STRING)   (VAL_V10_i2 0 :TYPE integer)   (V10_i3 "" :TYPE STRING)   (VAL_V10_i3 0 :TYPE integer)   (H01_o1 "" :TYPE STRING)   (VAL_H01_o1 0 :TYPE integer)   (H01_i1 "" :TYPE STRING)   (VAL_H01_i1 0 :TYPE integer)   (H02_o1 "" :TYPE STRING)   (VAL_H02_o1 0 :TYPE integer)   (H02_i1 "" :TYPE STRING)   (VAL_H02_i1 0 :TYPE integer)   (P01 "" :TYPE STRING)   (VAL_P01 0 :TYPE integer)   (P02 "" :TYPE STRING)   (VAL_P02 0 :TYPE integer)   (P03 "" :TYPE STRING)   (VAL_P03 0 :TYPE integer)   (TC01 "" :TYPE STRING)   (VAL_TC01 0 :TYPE integer)   (TC02 "" :TYPE STRING)   (VAL_TC02 0 :TYPE integer)   (TC03 "" :TYPE STRING)   (VAL_TC03 0 :TYPE integer)   (TC04 "" :TYPE STRING)   (VAL_TC04 0 :TYPE integer)   (TC05 "" :TYPE STRING)   (VAL_TC05 0 :TYPE integer)   (TC06 "" :TYPE STRING)   (VAL_TC06 0 :TYPE integer)   (TC07 "" :TYPE STRING)   (VAL_TC07 0 :TYPE integer)   (TC08 "" :TYPE STRING)   (VAL_TC08 0 :TYPE integer)   (TC09 "" :TYPE STRING)   (VAL_TC09 0 :TYPE integer)   (GA01 "" :TYPE STRING)   (VAL_GA01 0 :TYPE integer)   );; This is the format of the broadcast message;; 6 pumps;; 15 valves (5 3 ways);; 6 valves (2 way);; 15 valves (5 3 ways);; 4 heater ctrls;; 3 pressures;; 9 thermalcouples;; one gas analyzer;;#+ipc(ipc::ipc_defineFormat "vccr" "{string, string, #+ipc(ipc::ipc_defineFormat "vccr" "{string, int,     string, int, string, int, string, int,     string, int, string, int, string, int,    string, int, string, int, string, int, string, int, string, int,    string, int, string, int, string, int, string, int, string, int,    string, int, string, int, string, int, string, int, string, int,    string, int, string, int, string, int, string, int, string, int, string, int,    string, int, string, int, string, int, string, int, string, int,    string, int, string, int, string, int, string, int, string, int,    string, int, string, int, string, int, string, int, string, int,    string, int, string, int, string, int, string, int,     string, int, string, int, string, int,    string, int, string, int, string, int,    string, int, string, int, string, int,    string, int, string, int, string, int,    string, int}")(defparameter *ipc-broadcast-vccr-data* nil  "stores the data from the last broadcast message");; This handler basically calls the IPC version of update-vccr-sim.#+ipc(ipc:ipc_defun_handler vccr-bc-handler (message lisp-data client-data)  "Handle the broadcast message received over the IPC connection. Client-data:  (<device-broadcasting> . <msg-name>)"    (format t "~%msg name = ~a." client-data)    (setf *ipc-broadcast-vccr-data* lisp-data)     (format t "~%Time = ~a."  (aref lisp-data 2));     (format t "~%Time = ~a."  (coerce (aref lisp-data 2) 'string))     (update-vccr-sim-from-ipc));; For mcl (and maybe allegro) this subscribe must happen before the link is;; built, otherwise you get an error from IPC.#+(and IPC allegro)(if (link-exists? 'IPC-SKMGR-LINK)          (ipc::ipc_subscribe "vccr" 'vccr-bc-handler '(vccr . broadcast)))#+(and IPC mcl)(ipc::ipc_subscribe "vccr" 'vccr-bc-handler '(vccr . broadcast));;(ipc::ipc_unsubscribe "vccr" 'vccr-bc-handler);; This alist is used to map the data from the broadcast message to;; the objects in the sim.(defparameter *vccr-io-object-list*  '(:data     :time :val    :pu01o1 :val :vccr-internal-blower :val :pu02o1 :val :vccr-vacuum-pump :val     :pu03o1 :val :vccr-accum-pump :val ;; first two are outs next three are ins    :v01o1 :val :v01o2 :val :vccr-bed1-in :val :vccr-bed1-out :val :vccr-bed1-off :val    :v02o1 :val :v02o2 :val :vccr-bed2-in :val :vccr-bed2-out :val :vccr-bed2-off :val    :v03o1 :val :v03o2 :val :vccr-blower-in :val :vccr-blower-in2 :val :vccr-blower-off :val;; one out one in each    :v04o1 :val :vccr-blower-out-bed3 :val :v05o1 :val :vccr-blower-out-bed4 :val    :v06o1 :val :vccr-bed3-in :val :v07o1 :val :vccr-bed4-in :val;; first two are outs next three are ins    :v08o1 :val :v08o2 :val :vccr-desorb-bypass :val :vccr-desorb-bed4 :val :vccr-desorb-off :val    :v09o1 :val :v09o2 :val :vccr-vacuum-pump-in :val :space-vacuum-on :val :vccr-vacuum-pump-off :val    :v10o1 :val :v10o2 :val :vccr-vacuum-pump-out :val :vccr-pump-airsave :val :vccr-vacuum-pump-off :val;; one out one in each    :h01o1 :val :vccr-heater-bed3 :val :h01o1 :val :vccr-heater-bed4 :val;; pressure inputs    :vccr-xfer-xducer :val :vccr-store-xducer :val :vccr-water-xducer :val;;temp inputs    :vccr-input-temp :val :vccr-blower-input-temp :val :vccr-hx-output-temp :val    :vccr-bed4-temp1 :val :vccr-bed4-temp2 :val :vccr-bed4-temp3 :val    :vccr-bed3-temp1 :val :vccr-bed3-temp2 :val :vccr-bed3-temp3 :val;; co2 sensor    :vccr-cabin-co2 :val) "Maps sim objects to broadcast message data items.")(defparameter *debug* nil "Used to see the values that are extracted from the broadcast data.")(defun debug-out (format-string &rest args)"A function that prints values if *debug* is true."  (if *debug* (apply 'format t (append (list format-string) args))))  ;; (setf *debug* t);; (debug-out "~%Hello ~a." 'pete)#|(loop for i from 3 to (- (length *ipc-broadcast-vccr-data*) 2) by 2      do      (print (list (coerce (aref *ipc-broadcast-vccr-data* i) 'string)                    (aref *ipc-broadcast-vccr-data* (1+ i))                   (nth i *vccr-io-object-list*)                   (nth (1+ i) *vccr-io-object-list*))))|#;; The IPC updater. The basic approach is;; 1) Get the index of the object with ;; (setf index (1+ (position (name object) *vccr-io-object-list*))),;; Then set the data with ;; (setf (value object) (aref *ipc-broadcast-vccr-data* index)).(defun update-vccr-path-from-ipc (path-name path-data)  "The path update function for IPC. It uses the path data but essentially sets valuesbased on the results of the IPC broadcast message. "  (let* ((pump-object (get-object (second (assoc 'pump path-data))))         (pump (if pump-object pump-object (second (assoc 'pump path-data))));         (pump-status (third (assoc 'pump path-data)))         (heater-object (get-object (second (assoc 'heater path-data))))         (open-valves (rest (assoc 'open-valves path-data)))         (closed-valves (rest (assoc 'closed-valves path-data)))         (off-valves (rest (assoc 'off-valves path-data)))         (pipes (rename-pipes (first (rest (assoc 'path path-data))) '*vccr-objects*))         (anti-pipes (rename-pipes (first (rest (assoc 'anti-path path-data))) '*vccr-objects*))         (ps (rest (assoc 'ps path-data)));         (global-if-ok (second (assoc 'global-if-ok path-data)));         (depends-on (second (assoc 'depends-on path-data)))         (ms (second (assoc 'ms path-data)))         (all-valves-good? (and (all-valves-from-ipc? *vccr-io-object-list* *ipc-broadcast-vccr-data* open-valves 'open)                                (all-valves-from-ipc? *vccr-io-object-list* *ipc-broadcast-vccr-data* closed-valves 'closed)                                (all-valves-from-ipc? *vccr-io-object-list* *ipc-broadcast-vccr-data* off-valves 'off)))         index)    ;; update the pipes;;    (format t "~%All valves are ~a good for ~a." (if all-valves-good? 'so 'not) path-name);;    (break "WHoa nellie!")    #|    (format t "~%Valves = ~a, ~a; ~a, ~a; ~a, ~a."             open-valves (all-valves? *vccr-io-object-list* *ipc-broadcast-vccr-data* open-valves 'open)            closed-valves (all-valves? *vccr-io-object-list* *ipc-broadcast-vccr-data* closed-valves 'closed)            off-valves (all-valves? *vccr-io-object-list* *ipc-broadcast-vccr-data* off-valves 'off))|#          (when pump-object        (setf index (1+ (position (name pump-object) *vccr-io-object-list*)))        (debug-out "~%~a reads ~a." (name pump-object) (aref *ipc-broadcast-vccr-data* index)))      (loop for p in anti-pipes          as pipe-object = (if (eq (first anti-pipes) 'all)                               p                               (get-object p))          if (eq (class-name (class-of pipe-object)) 'air-pipe)          do          (if (and (not (member p pipes))                   (or (not pump)                       (eq pump 'space-vacuum)                       (> (aref *ipc-broadcast-vccr-data* index) 0))                   all-valves-good?)              (setf (material-in? pipe-object) nil)))      (loop for p in pipes             as pipe-object = (get-object p)            do            ;; (break "WHoa nellie!")            (cond ((and (or (not pump)                            (eq pump 'space-vacuum)                            (> (aref *ipc-broadcast-vccr-data* index) 0))                        all-valves-good?)                   (setf (material-in? pipe-object) t))                ((and pump-object                      (<= (aref *ipc-broadcast-vccr-data* index) 0)                      all-valves-good?;; p34 should be on always until we shut the thing down.                      (not (eq p (first (rename-pipes '(p34) '*vccr-objects*)))))                 (setf (material-in? pipe-object) nil))))        ;; pressure ducers        (loop for p in ps          as pobj = (get-object p)          do          (setf index (1+ (position p *vccr-io-object-list*)))          (debug-out "~%~a reads ~a." p (aref *ipc-broadcast-vccr-data* index))          (setf (pressure pobj) (aref *ipc-broadcast-vccr-data* index)))        ;; Now the mission (temperature) sensors, looking at        (case path-name      (accum (loop for m in ms                   as mobj = (get-object m)                   do                   (setf index (1+ (position m *vccr-io-object-list*)))                   (debug-out "~%~a reads ~a." m (aref *ipc-broadcast-vccr-data* index))                   (if (eq m :vccr-cabin-co2)                       (setf (cur-value mobj)(aref *ipc-broadcast-vccr-data* index))                       (setf (pressure mobj) (aref *ipc-broadcast-vccr-data* index)))))      (otherwise       (loop for ts in ms             as tobj = (get-object ts)             do             (setf index (1+ (position ts *vccr-io-object-list*)))             (debug-out "~%~a reads ~a." ts (aref *ipc-broadcast-vccr-data* index))             (setf (temperature tobj)                    (abs (aref *ipc-broadcast-vccr-data* index))))))        ;; co2 bed heaters        (if heater-object        (loop for temp in               (if (eq (second (assoc 'heater path-data)) :vccr-heater-bed3)                  '(:vccr-bed3-temp1 :vccr-bed3-temp2 :vccr-bed3-temp3)                  '(:vccr-bed4-temp1 :vccr-bed4-temp2 :vccr-bed4-temp3))              as tobj = (get-object temp)              do              ;;              (break "WHoa nellie!")              (setf index (1+ (position temp *vccr-io-object-list*)))              (debug-out "~%~a reads ~a." temp (aref *ipc-broadcast-vccr-data* index))              (setf (temperature tobj)                     (abs (aref *ipc-broadcast-vccr-data* index)))))    #+mcl(update-vccr-path-display path-name path-data)))(defparameter *vccr-subscribed* nil);; The counterpart to update-vccr-sim.(defun update-vccr-sim-from-ipc ()"Goes thru the flow paths and calls update-bioreactor-path."  (let ((path-names (first *vccr-objects-in-paths*))        (path-data (rest *vccr-objects-in-paths*)))    (loop for name in path-names          do          (update-vccr-path-from-ipc name (rest (assoc name path-data)));          (break "Yallow!")          )#+(and IPC MCL)(update-grafx 'vccr '*vccr-objects*)        ));; (update-vccr-sim-from-ipc);; A function I use to test the IPC sim functions.#+IPC(defun read-and-display () (ipc::ipc_subscribe "vccr" 'vccr-bc-handler '(vccr . broadcast))   (if (ipc:ipc_isconnected)       (ipc:ipc_listenclear 0)       (format t "~%IPC is not connected."));   (break "At read and display")   (if *ipc-broadcast-vccr-data*       (update-vccr-sim-from-ipc))  (ipc::ipc_unsubscribe "vccr" 'vccr-bc-handler)  );; (loop (read-and-display));;(read-and-display)                    